# 객체 지향

우리는 이전 두 절에서 함수와 구조체에 대해 살펴봤습니다. 그런데 구조체의 필드로 함수를 사용하는 것을 고려한 적이 있나요? 이 절에선, `메서드`라고 불리는 리시버를 갖는 또 다른 형태의 함수를 소개하려고 합니다.

## 메서드

"직사각형" 구조체를 정의한다고 가정하고 이 도형의 넓이를 계산하고 싶다고 해봅시다. 우리는 보통 다음과 같이 코드를 작성합니다.

```go
package main
import "fmt"

type Rectangle struct {
	width, height float64
}

func area(r Rectangle) float64 {
	return r.width*r.height
}

func main() {
	r1 := Rectangle{12, 2}
	r2 := Rectangle{9, 4}
	fmt.Println("Area of r1 is: ", area(r1))
	fmt.Println("Area of r2 is: ", area(r2))
}
```

위 예제는 직사각형의 넓이를 계산합니다. 우리는 `area`라는 함수를 사용하지만 이는 직사각형 구조체의 메서드 (클래스 기반 객제지향 언어에서의 클래스 메서드와 유사한)는 아닙니다. 여러분도 볼 수 있듯이 위의 함수와 구조체는 서로 독립적입니다.

지금까지는 문제가 없습니다. 그러나, 만약 원, 정사각형, 오각형 또는 다른 종류의 도형들의 넓이를 계산해야 하는 경우, 매우 유사한 이름을 가진 추가적인 함수들을 추가해야합니다.

![](images/2.5.rect_func_without_receiver.png?raw=true)

Figure 2.8 함수와 구조체의 관계 

분명하게도 이는 썩 좋은 방법은 아닙니다. 또한, 넓이는 실제로 원이나 직사각형의 속성이 되어야합니다.

위의 이유들로, Go에는 `메서드` 개념이 있습니다. `메서드`는 타입과 관련됩니다. 이는 `func` 키워드 뒤에 메서드의 주체인 `리시버`라는 추가적인 파라미터가 온다는 점을 제외하면 함수와 동일한 구문을 가집니다. 

같은 예제를 사용하면, `Rectangle.area()`는 독립적인 함수가 아닌 직사각형 구조체에 직접적으로 속해 있습니다. 좀 더 구체적으로는, `length`, `width` 그리고 `area()` 모두 직사각형 구조체에 속합니다. 

Rob Pike가 말했듯이.

	"메서드는 리시버라고 하는 암시적인 첫 번째 인자를 가진 함수입니다."
메서드 구문.

```go
func (r ReceiverType) funcName(parameters) (results)
```
`메서드`를 사용해 예제를 변경해봅시다.

```go
package main
import (
	"fmt"
	"math"
)

type Rectangle struct {
	width, height float64
}

type Circle struct {
	radius float64
}

func (r Rectangle) area() float64 {
	return r.width*r.height
}

func (c Circle) area() float64 {
	return c.radius * c.radius * math.Pi
}

func main() {
	r1 := Rectangle{12, 2}
	r2 := Rectangle{9, 4}
	c1 := Circle{10}
	c2 := Circle{25}

	fmt.Println("Area of r1 is: ", r1.area())
	fmt.Println("Area of r2 is: ", r2.area())
	fmt.Println("Area of c1 is: ", c1.area())
	fmt.Println("Area of c2 is: ", c2.area())
}
```

메서드 사용시 주의 사항.

- 메서드명이 같아도 리시버가 다르면, 서로 다른 메서드입니다.
- 메서드는 리시버의 필드에 접근 가능합니다.
- 필드를 호출하는법과 동일하게 구조체 메서드를 호출할 때  `.`을 사용합니다.

![](images/2.5.shapes_func_with_receiver_cp.png?raw=true)

Figure 2.9 다른 구조체의 다른 메서드

위 예제에서, 두 `area()` 메서드는 각각 `Rectangle`과 `Circle`에 속해있으므로, 리시버는 각각 `Rectangle`과 `Circle`입니다.

여기서 주목할 만 한것중 하나는 점선으로 표시된 메서드는 리시버가 레퍼런스가 아닌 값으로 전달됨을 의미합니다. 이 둘의 차이점은 리시버가 레퍼런스로 전달되는 경우엔 메서드가 리비서의 값을 변경할 수 있으며, 값으로 전달되는 경우엔 메서드가 리시버의 복사본을 얻는다는 점입니다.

리시버는 반드시 구조체여만 할까요? 물론 아닙니다. 모든 타입이 메서드의 리시버가 될 수 있습니다. 사용자 정의 타입에 대해 혼란스러울 수도 있습니다. 구조체는 사용자 정의 타입의 특수한 형태이며 더 많은 사용자 정의 타입이 있습니다. 

사용자 정의 타입을 정의하기 위해 다음 구문을 사용합니다.

```go
type typeName typeLiteral
```
사용자 정의 타입의 예시:


```go
type ages int

type money float32

type months map[string]int

m := months {
	"January":31,
	"February":28,
	...
	"December":31,
}
```

저자는 이제 여러분이 사용자 정의 타입을 어떻게 사용하는지 알길 바랍니다. C에서의 `typedef`와 유사하게, 위 예제에서 우리는  `args`를 사용해 `int`를 대체합니다. 

다시 `메서드` 얘기로 돌아갑시다.

여러분은 사용자 정의 타입에 원하는 만큼의 메서드를 추가할 수 있습니다.

```go
package main
import "fmt"

const(
	WHITE = iota
	BLACK
	BLUE
	RED
	YELLOW
)

type Color byte

type Box struct {
	width, height, depth float64
	color Color
}

type BoxList []Box // 박스의 슬라이스

func (b Box) Volume() float64 {
	return b.width * b.height * b.depth
}

func (b *Box) SetColor(c Color) {
	b.color = c
}

func (bl BoxList) BiggestsColor() Color {
	v := 0.00
	k := Color(WHITE)
	for _, b := range bl {
    	if b.Volume() > v {
        	v = b.Volume()
        	k = b.color
    	}
	}
	return k
}

func (bl BoxList) PaintItBlack() {
	for i, _ := range bl {
    	bl[i].SetColor(BLACK)
	}
}

func (c Color) String() string {
	strings := []string {"WHITE", "BLACK", "BLUE", "RED", "YELLOW"}
	return strings[c]
}

func main() {
	boxes := BoxList {
    	Box{4, 4, 4, RED},
    	Box{10, 10, 1, YELLOW},
    	Box{1, 1, 20, BLACK},
    	Box{10, 10, 1, BLUE},
    	Box{10, 30, 1, WHITE},
    	Box{20, 20, 20, YELLOW},
	}

	fmt.Printf("We have %d boxes in our set\n", len(boxes))
	fmt.Println("The volume of the first one is", boxes[0].Volume(), "cm³")
	fmt.Println("The color of the last one is",boxes[len(boxes)-1].color.String())
	fmt.Println("The biggest one is", boxes.BiggestsColor().String())

	fmt.Println("Let's paint them all black")
	boxes.PaintItBlack()
	fmt.Println("The color of the second one is", boxes[1].color.String())

	fmt.Println("Obviously, now, the biggest one is", boxes.BiggestsColor().String())
}
```

몇 가지 상수와 사용자 정의 타입을 정의합니다.

- `byte`의 별칭으로 `Color`를 사용합니다.
- height, width, length 및 color 필드를 갖는 `Box` 구조체를 정의합니다.
- `Box`를 필드로 갖는 `BoxList`를 정의합니다.

그 다음 사용자 정의 타입의 몇 가지 메서드를 정의합니다.

- `Volume`은 리시버로 `Box`를 사용하며 박스의 부피를 반환합니다.
- `SetColor(c Color)`는 박스의 색상을 변경합니다.
- `BiggestsColor()`는 가장 큰 부피를 갖는 박스의 색상을 반환합니다.
- `PaintBlack()`은 `BoxList`의 모든 박스들의 색상을 검정색으로 설정합니다.
- `String()`은 리시버로 `Color`를 사용하며 색상명의 문자열 형식을 반환합니다.

요구사항을 말로 설명하니까 좀 더 명확하지 않나요? 우리는 종종 코딩을 시작하기 전에 요구사항을 작성합니다.

### 리시버로 포인터 사용

`SetColor` 메서드를 살펴봅시다. 이 메서드의 리시버는 `Box`의 포인터입니다. 네 맞습니다, 리시버로 `*Box`를 사용할 수 있습니다. 여기서 왜 포인터를 사용할까요? 그 이유는 우리가 메서드 내에서 `Box`의 `color`값을 변경하기 위해서입니다. 따라서, 만약 포인터를 사용하지 않는다면, 이는 `Box`의 복사본의 값만을 변경합니다.

리시버가 메서드의 첫 번째 인자인걸 알게되면, 메서드가 어떻게 동작하는지 이해하는 것은 어렵지 않습니다.

아마 `SetColor()` 메서드에서 왜 `(*b).Color=c`가 아닌 `b.Color=c`를 사용하는지 궁금해할 수 있습니다. Go는 할당을 해석하는 방법을 알고 있기 때문에 두 방법 모두 사용 가능합니다. Go가 더욱 매력적이라고 생각되지 않나요?

여러분은 또한 우리가 `SetColor`에 포인터를 전달했으므로 `PaintItBlack`에서는 `(&bl[i]).SetColor(BLACK)` 로 써야하는건 아닌지에 대한 질문을 할 수도 있습니다. 다시 말하지만, Go는 이를 해석하는 방법을 알고 있으므로 두 방법 모두 사용 가능합니다.

### 메서드 상속

우리는 마지막 절에서 필드 상속에 대해 배웠습니다. 이와 유사하게, Go에는 메서드 상속 또한 있습니다. 어떤 익명 필드가 메서드를 가지고 있으면, 이 필드를 포함하는 구조체는 이 필드의 모든 메서드를 갖게됩니다.

```go
package main
import "fmt"

type Human struct {
	name string
	age int
	phone string
}

type Student struct {
	Human // 익명 필드
	school string
}

type Employee struct {
	Human 
	company string
}

// Human에 메서드 정의
func (h *Human) SayHi() {
	fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

func main() {
	mark := Student{Human{"Mark", 25, "222-222-YYYY"}, "MIT"}
	sam := Employee{Human{"Sam", 45, "111-888-XXXX"}, "Golang Inc"}

	mark.SayHi()
	sam.SayHi()
}
```

### 메서드 오버로드

`Employee`가 자체 메서드 `SayHi`를 가지길 원한다면, `Employee`에 동일한 이름의 메서드를 정의할 수 있으며, 이 메서드를 호출하면 이는 `Human`의 `SayHi`를 감춥니다. (즉, `Human`의 `SayHi`가 아닌 `Employee`의 `SayHi`를 호출)

```go
package main
import "fmt"

type Human struct {
	name string
	age int
	phone string
}

type Student struct {
	Human 
	school string
}

type Employee struct {
	Human 
	company string
}

func (h *Human) SayHi() {
	fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

func (e *Employee) SayHi() {
	fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name,
    	e.company, e.phone) // 한 줄을 두 줄로 나눌 수도 있습니다.
}

func main() {
	mark := Student{Human{"Mark", 25, "222-222-YYYY"}, "MIT"}
	sam := Employee{Human{"Sam", 45, "111-888-XXXX"}, "Golang Inc"}

	mark.SayHi()
	sam.SayHi()
}
```

이제 여러분은 객체 지향 프로그램을 작성할 수 있으며 대문자 규칙을 사용하여 메서드의 공개 또는 비공개 여부를 결정할 수 있습니다.

## 링크

- [목차](preface.md)
- 이전 글: [struct](02.4.md)
- 다음 글: [interface](02.6.md)
