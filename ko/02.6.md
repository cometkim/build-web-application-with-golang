# 2.6 인터페이스

## Interface

Go에서 가장 미묘하게 디자인된 기능 중 하나는 인터페이스입니다. 이번 장을 읽고나면 인터페이스 구현에 깊은 인상을 받을 것 입니다.

### 인터페이스가 뭔가요?

간단하게 말하면, 인터페이스는 메쏘드의 조합입니다. 인터페이스를 통해 개체의 행동을 정의 할 수 있습니다.

이전 장의 마지막 예제에서는 Student와 Employee 모두 `SayHi()`를 가지고있었습니다. 그들의 내부 처리는 다르지만, 그것은 중요하지 않습니다. 중요한 것은 그들이 모두`say hi`라고 말할 것입니다.

좀 더 작업을 추가해봅시다. Student엔 `BorrowMoney()` 메쏘드를 Employee엔 `SpendSalary()` 메쏘드를 추가하고, 양쪽에 `Sing()` 메쏘드를 추가합니다.

이제 Student는 `SayHi()`, `Sing()`및 `BorrowMoney()`라는 세 가지 메쏘드를 사용하며 Employee는 `SayHi()`, `Sing()` 및 `SpendSalary()`를 사용합니다.

이와 같은 조합을 인터페이스라고하며 Student와 Employee이 모두 구현합니다. 그래서, Student와 Employee는 `SayHi()`와 `Sing()` 인터페이스를 구현합니다. 동시에, Employee는 인터페이스 `BorrowMoney()`를 구현하지 않으며, Student는 인터페이스 `SpendSalary()`를 구현하지 않습니다. 왜냐하면 Employeer가 `BorrowMoney()` 메소드를 가지고 있지 않고 Student가 `SpendSalary()` 메소드를 가지고 있지 않기 때문입니다.


### 인터페이스의 타입

인터페이스는 일련의 메소드를 정의하므로, 타입이 모든 메소드를 구현하면 인터페이스를 구현한다고 말합니다.

```go
type Human struct {
    name  string
    age   int
    phone string
}

type Student struct {
    Human
    school string
    loan   float32
}

type Employee struct {
    Human
    company string
    money   float32
}

func (h *Human) SayHi() {
    fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

func (h *Human) Sing(lyrics string) {
    fmt.Println("La la, la la la, la la la la la...", lyrics)
}

func (h *Human) Guzzle(beerStein string) {
    fmt.Println("Guzzle Guzzle Guzzle...", beerStein)
}

// Employee에 SayHi()를 오버라이드합니다.
func (e *Employee) SayHi() {
    fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name,
        e.company, e.phone) // 이 곳을 두 줄로 나눠 쓰는 것이 가능합니다.
}

func (s *Student) BorrowMoney(amount float32) {
    s.loan += amount // (반복합니다.)
}

func (e *Employee) SpendSalary(amount float32) {
    e.money -= amount // 보드카 더 주세요! 이날 저를 찾으세요!
}

// 인터페이스를 정의합니다.
type Men interface {
    SayHi()
    Sing(lyrics string)
    Guzzle(beerStein string)
}

type YoungChap interface {
    SayHi()
    Sing(song string)
    BorrowMoney(amount float32)
}

type ElderlyGent interface {
    SayHi()
    Sing(song string)
    SpendSalary(amount float32)
}
```

인터페이스는 모든 타입으로 구현 될 수 있으며 하나의 타입은 많은 인터페이스를 동시에 구현할 수 있습니다.

모든 타입은 빈 인터페이스 `interface {}`를 구현합니다. 왜냐하면 어떤 메소드도 없기 때문이며 모든 타입은 기본적으로 제로-메쏘드입니다.

### 인터페이스의 값

그러면 어떤 종류의 값을 인터페이스에 넣을 수 있을까요? 변수를 타입 인터페이스로 정의하면 인터페이스를 구현하는 모든 타입을 이 변수에 할당 할 수 있습니다.

위의 예와 같이 변수 `m`을 Men이라는 인터페이스로 정의하면 Student, Human 또는 Employee 중 하나를 `m`에 할당 할 수 있습니다. 따라서 우리는 Men 슬라이스를 가질 수 있으며 Men 인터페이스를 구현한 어떤 타입에도 이 슬라이스를 할당할 수 있습니다. 그러나 인터페이스 슬라이스는 다른 유형의 슬라이스와 동일한 동작을 하지 않습니다.

```go
package main

import "fmt"

type Human struct {
    name  string
    age   int
    phone string
}

type Student struct {
    Human
    school string
    loan   float32
}

type Employee struct {
    Human
    company string
    money   float32
}

func (h Human) SayHi() {
    fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

func (h Human) Sing(lyrics string) {
    fmt.Println("La la la la...", lyrics)
}

func (e Employee) SayHi() {
    fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name,
        e.company, e.phone) // 이 곳을 두 줄로 나눠 쓰는 것이 가능합니다.
}

// 인터페이스 Men은 Human, Student, Employee를 구현합니다.
type Men interface {
    SayHi()
    Sing(lyrics string)
}

func main() {
    mike := Student{Human{"Mike", 25, "222-222-XXX"}, "MIT", 0.00}
    paul := Student{Human{"Paul", 26, "111-222-XXX"}, "Harvard", 100}
    sam := Employee{Human{"Sam", 36, "444-222-XXX"}, "Golang Inc.", 1000}
    tom := Employee{Human{"Sam", 36, "444-222-XXX"}, "Things Ltd.", 5000}

    // 인터페이스 i를 정의합니다
    var i Men

    //i에 Student를 저장할 수 있습니다.
    i = mike
    fmt.Println("This is Mike, a Student:")
    i.SayHi()
    i.Sing("November rain")

    //i에 Employee를 저장할 수 있습니다.
    i = tom
    fmt.Println("This is Tom, an Employee:")
    i.SayHi()
    i.Sing("Born to be wild")

    // Men의 슬라이스
    fmt.Println("Let's use a slice of Men and see what happens")
    x := make([]Men, 3)
    // 이 3가지 요소는 서로 다른 타입이지만 Men 인터페이스를 구현했습니다.
    x[0], x[1], x[2] = paul, sam, mike

    for _, value := range x {
        value.SayHi()
    }
}
```
	
인터페이스는 추상 메소드 세트이며 비 인터페이스 유형으로 구현할 수 있기 때문에 자체 구현할 수 없습니다.

### 빈 인터페이스

빈 인터페이스는 메소드를 포함하지 않는 인터페이스이므로 모든 타입은 빈 인터페이스를 구현합니다. 이 사실은 모든 타입을 어느 시점에 저장하고자 할 때 매우 유용하며 C에서 `void*`와 유사합니다.

```go
// 빈 인터페이스를 정의합니다.
var a interface{}
var i int = 5
s := "Hello world"
// a는 어떤 타입의 값이라도 저장할 수 있습니다.
a = i
a = s
```

함수가 빈 인터페이스를 인수 타입으로 사용하면 모든 유형을 사용할 수 있습니다. 함수가 반환 값 타입으로 빈 인터페이스를 사용하는 경우 모든 타입을 반환 할 수 있습니다.

### 인터페이스의 메소드 인수

모든 변수는 인터페이스에서 사용할 수 있습니다. 그렇다면 이 기능을 사용하여 어떤 타입의 변수를 함수에 전달할 수 있을까요?

예를 들어 우리는 `fmt.Println`을 많이 사용해왔지만 이것이 어떤 타입의 인수도 허용 할 수 있다는 사실을 알고 있었나요? fmt의 오픈 소스 코드를 살펴보면 다음과 같은 정의를 볼 수 있습니다.

```go
type Stringer interface {
        String() string
}
```
	
즉, Stringer 인터페이스를 구현하는 모든 유형을 인수로 fmt.Println에 전달할 수 있습니다. 증명해 보죠.

```go
package main

import (
    "fmt"
    "strconv"
)

type Human struct {
    name  string
    age   int
    phone string
}

// Human은 fmt.Stringer를 구현합니다.
func (h Human) String() string {
    return "Name:" + h.name + ", Age:" + strconv.Itoa(h.age) + " years, Contact:" + h.phone
}

func main() {
    Bob := Human{"Bob", 39, "000-7777-XXX"}
    fmt.Println("This Human is : ", Bob)
}
```
	
Box의 예를 살펴보면, Color가 인터페이스 Stringer도 구현한다는 것을 알 수 있습니다. 따라서 프린트 포맷을 사용자 정의 할 수 있습니다. 이 인터페이스를 구현하지 않으면 `fmt.Println`은 포멧을 기본 포멧으로 프린트합니다.

```go
fmt.Println("The biggest one is", boxes.BiggestsColor().String())
fmt.Println("The biggest one is", boxes.BiggestsColor())
```
	
주의: 만일 타입이 인터페이스 `error`를 구현했다면, fmt는 `error()`를 호출 할 것이므로, 이 시점에서 Stringer를 구현할 필요가 없다.

### 인터페이스의 변수 타입

변수가 인터페이스를 구현하는 타입이면 동일한 인터페이스를 구현하는 다른 타입을 이 변수에 할당 할 수 있습니다. 문제는 인터페이스에 저장된 특정 타입을 어떻게 알 수 있는가입니다. 여기에 두 가지 방법이있습니다.

- Comma-ok pattern의 어설션

Go는 `value, ok := element.(T)` 같은 구문이 존재합니다. 변수가 우리가 예상하는 타입인지 확인합니다. 여기서 "value"는 변수의 값이고 "ok"는 부울 타입의 변수이고 "element"는 인터페이스 변수이며 T는 어설션 타입입니다 .

요소가 예상 한 타입이라면 true, 아니면 false입니다. 

좀 더 명확한 이해를 위해 예제를 살펴봅시다.

```go
package main

import (
    "fmt"
    "strconv"
)

type Element interface{}
type List []Element

type Person struct {
    name string
    age  int
}

func (p Person) String() string {
    return "(name: " + p.name + " - age: 	" + strconv.Itoa(p.age) + " years)"
}

func main() {
    list := make(List, 3)
    list[0] = 1       // int
    list[1] = "Hello" // string
    list[2] = Person{"Dennis", 70}

    for index, element := range list {
        if value, ok := element.(int); ok {
            fmt.Printf("list[%d] is an int and its value is %d\n", index, value)
        } else if value, ok := element.(string); ok {
            fmt.Printf("list[%d] is a string and its value is %s\n", index, value)
        } else if value, ok := element.(Person); ok {
            fmt.Printf("list[%d] is a Person and its value is %s\n", index, value)
        } else {
            fmt.Printf("list[%d] is of a different type\n", index)
        }
    }
}
```

이 패턴을 사용하는 것은 꽤나 쉽지만 많은 타입을 테스트 해야 한다면 `switch`를 사용하는 것이 좋습니다.

- switch 테스트

위의 예제를 `switch`를 사용하여 다시 작성해봅시다.

```go
package main

import (
    "fmt"
    "strconv"
)

type Element interface{}
type List []Element

type Person struct {
    name string
    age  int
}

func (p Person) String() string {
    return "(name: " + p.name + " - age: " + strconv.Itoa(p.age) + " years)"
}

func main() {
    list := make(List, 3)
    list[0] = 1       //an int
    list[1] = "Hello" //a string
    list[2] = Person{"Dennis", 70}

    for index, element := range list {
        switch value := element.(type) {
        case int:
            fmt.Printf("list[%d] is an int and its value is %d\n", index, value)
        case string:
            fmt.Printf("list[%d] is a string and its value is %s\n", index, value)
        case Person:
            fmt.Printf("list[%d] is a Person and its value is %s\n", index, value)
        default:
            fmt.Println("list[%d] is of a different type", index)
        }
    }
}
```
	
한가지 기억해야 할 것은 `element.(type)`은 `switch` 본문 밖에선 사용할 수 없습니다. 만약 필요하다면 `comma-ok` 패턴을 사용해야합니다.

### 임베딩 인터페이스

가장 아름다운 것은 Go가 구조체에 익명 필드와 같은 많은 내장 논리 구문을 가지고 있다는 것입니다. 당연하게도 우리는 인터페이스를 익명 필드로 사용할 수도 있지만 '임베딩 인터페이스'라고 부르는 것을 사용할 수도 있습니다. 임베딩 인터페이스는 익명 필드와 동일한 규칙을 따릅니다. 더 구체적으로 말하면, 인터페이스에 다른 인터페이스가 내장되어 있으면 인터페이스에 포함 된 모든 메소드가 있는 것처럼 작동합니다.

`container/heap`에 있는 소스 파일의 정의는 다음과 같습니다 :

```go
type Interface interface {
        sort.Interface // 임베딩 sort.Interface
        Push(x interface{}) //Push 메쏘드는 heap 안에 원소를 넣습니다.
        Pop() interface{} //Pop 메쏘드는 heap 안에서 원소를 뺍니다.
}
```

`sort.Interface`는 임베딩 인터페이스이므로 위의 인터페이스에는 암시 적으로 `sort.Interface`내에 포함 된 세 가지 메소드가 있습니다.

```go
type Interface interface {
        // Len은 컬렉션의 요소 수입니다.
        Len() int
        // Less는 인덱스가 i 인 요소가 인덱스가 j 인 요소보다 먼저 정렬해야하는지 여부를 반환합니다.
        Less(i, j int) bool
        // Swap은 인덱스 i와 j의 요소를 교환합니다.
        Swap(i, j int)
}
```
	
또 다른 예로는 `io` 패키지에 있는 `io.ReadWriter`가 있습니다.
```go
// io.ReadWriter
type ReadWriter interface {
        Reader
        Writer
}
```
	
### Reflection

Go에서 리플렉션은 런타임에 정보를 판별하는 데 사용됩니다. `reflect` 패키지를 사용합니다. 이 공식 [article](http://golang.org/doc/articles/laws_of_reflection.html)은 Go에서 리플렉션이 어떻게 작동하는지 설명합니다.

리플렉션을 사용하려면 3 단계로 나눌 수 있습니다. 아래에 간단하게 설명합니다 : 리플렉션 타입의 값 (이 값은 빈 인터페이스를 구현하고 있습니다.) 우선 이것을 리플렉션 객체로 변환해야합니다 (reflect.Type 또는 reflect.Value입니다. 다른 상황에 따라 다른 함수를 호출합니다.) 이 두 가지를 얻을 수있는 방법은 :

```go
t := reflect.TypeOf(i)    // 타입 i의 메타 데이터를 가져오고, t를 사용하여 모든 요소를 가져옵니다.
v := reflect.ValueOf(i)   // 타입 i에서 실제 값을 얻고 v를 사용하여 값을 변경합니다.
```
	
그 후, 우리는 필요한 값을 얻기 위해 리플렉션 된 타입을 변환 할 수 있습니다.

```go
var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println("type:", v.Type())
fmt.Println("kind is float64:", v.Kind() == reflect.Float64)
fmt.Println("value:", v.Float())
```
	
마지막으로 리플렉션 된 타입의 값을 변경하려면 수정할 수 있도록 해야 합니다. 앞에서 언급했듯이, 값 전달과 레퍼런스 전달의 차이가 있습니다. 다음 코드는 컴파일되지 않습니다.

```go
var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1)
```
	
대신 다음 코드를 사용하여 리플렉션 타입에서 값을 변경해야합니다.

```go
var x float64 = 3.4
p := reflect.ValueOf(&x)
v := p.Elem()
v.SetFloat(7.1)
```

우리는 방금 리플렉션의 기초를 살펴봤지만, 더 많이 이해하기 위해서는 더 많은 연습을 해야합니다.

## 링크

- [목차](preface.md)
- 이전 글: [객체 지향](02.5.md)
- 다음 글: [동시성](02.7.md)
