# 2.2 Go 기초

이번 장에서, Go 프로그래밍에서 상수, 기본 타입의 변수 정의하는 방법 및 몇가 기술을 알려 드리려고합니다.

## Define variables

Go에서 변수를 정의하는 데 사용할 수 있는 다양한 형식의 구문이 있습니다.

`var` 키워드는 변수를 정의하는 기본 형식입니다. Go는 변수 이름 뒤에 변수 타입 `type`을 넣습니다.

```go
// “variableName”과 타입을 함께 정의합니다.
var variableName type
```

여러개의 변수 정의하기

```go
// 3개의 변수를 타입과 함께 정의합니다.
var vname1, vname2, vname3 type
```
	
초기 값을 가진 변수를 정의하기

```go
// 이름이 “variableName”, 타입이 "type" 그리고 값이 "value"인 변수를 정의합니다.
var variableName type = value
```
	
여러개의 변수를 초기 값과 함께 정의하기
```go
/*
"type" 타입을 가진 3개의 변수를 정의하고 그 값을 초기화합니다.
vname1 = v1, vname2 = v2, vname3 = v3
*/
var vname1, vname2, vname3 type = v1, v2, v3
```
	
변수를 정의하는 것이 너무 지루하다고 생각하세요? 걱정마세요, 왜냐하면 Go 팀도 이 문제를 발견했기 때문입니다. 따라서 초기 값을 사용하여 변수 타입을 생략한체 변수를 정의할 수 있습니다. 코드는 다음과 같이 표시됩니다.

```go

/*
타입을 정하지 않은 3개의 변수를 정의하고 그 값을 초기화합니다.
vname1 is v1，vname2 is v2，vname3 is v3
*/
var vname1, vname2, vname3 = v1, v2, v3
```

네, 여러분이 아직 만족할 수준으로 간단해지지 않았다는 것을 압니다. 우리가 이것을 어떻게 고치는지 다시 살펴봅시다.

```go
/*
타입을 정하지 않고 "var" 키워드도 없는 세개의 변수를 정의하고 그 값을 초기화합니다.
vname1 is v1，vname2 is v2，vname3 is v3
*/
vname1, vname2, vname3 := v1, v2, v3
```
	
이제야 좀 보기 좋아졌군요. `:=`를 사용하여 `var`과 `type`을 대체했습니다. 이것을 간결한 구문(brief statement)이라고합니다. 하지만, 한 가지 제한이 있습니다. 이 구문은 함수 내부에서만 사용할 수 있고 함수 밖에서 사용하려고하면 컴파일 오류가 발생합니다. 그러므로 일반적으로 전역 변수를 정의하기 위해선 `var` 키워드를 사용합니다.

`_`(공백)은 특별한 변수 이름입니다. 이것에 주어진 값은 무시됩니다. 예를 들어 `b`에 `35`를 주고 `34`를 버립니다.( ***이 예제는 단순히 어떻게 작동하는지 보여주기위해 작성하였습니다. 쓸데 없이 보일지 몰라도 함수의 반환값을 얻을 땐 종종 이 기호를 사용합니다.*** )

```go
_, b := 34, 35
```
	
프로그램에서 정의한 변수를 사용하지 않으면 컴파일러에서 컴파일 오류를 표시합니다. 다음 코드를 컴파일하고 무슨 일이 일어나는지 보세요.

```go
package main

func main() {
    var i int
}
```
	
## 상수(Constants)

상수는 컴파일시에 결정되는 값이며 런타임 중에 변경할 수 없습니다. Go에서는 숫자, 부울(boolean) 또는 문자열 타입을 상수로 사용할 수 있습니다.

다음과 같이 상수를 정의하세요.

```go
const constantName = value
// 필요한 경우 상수 타입을 지정할 수 있습니다.
const Pi float32 = 3.1415926
```

더 많은 예제.

```go
const Pi = 3.1415926
const i = 10000
const MaxThread = 10
const prefix = "astaxie_"
```

## 기본 타입

### 부울(Boolean)

Go에서는 변수를 부울 타입으로 정의하기 위해 `bool`을 사용합니다. 값은 `true` 또는 `false` 만 가능하고 `false`가 기본값입니다. ( ***여러분은 변수의 타입을 숫자에서 부울로 부울에서 숫자로 변환 할 수 없습니다.*** )

```go
// 예제 코드
var isActive bool  // 전역 변수
var enabled, disabled = true, false  // 변수의 타입을 생략
func test() {
    var available bool  // 지역 변수
    valid := false      // 변수를 정의할 때 간략한 구문 사용
    available = true    // 변수에 값 할당
}
```
	
### 수 타입

정수형 타입(Integer type)에는 부호있는 정수 타입과 부호없는 정수 타입이 모두 포함됩니다. Go는 `int`와 `uint`를 동시에 가지며 길이는 같지만 운영체제에 따라 길이가 다릅니다. 32 비트 운영 체제에서는 32 비트를, 64 비트 운영 체제에서는 64 비트를 사용합니다. Go는 또한 `rune`, `int8`, `int16`, `int32`, `int64`, `byte`, `uint8`, `uint16`, `uint32`, `uint64`과 같은 특정한 길이를 가진 타입을 가지고 있습니다. `rune`은 `int32`의 별명이고 `byte`는 `uint8`의 별명입니다.

한 가지 중요한 점은 이러한 타입간에 값을 할당 할 수 없다는 사실을 알아야합니다. 이러한 연산은 컴파일 오류를 발생시킵니다.

```go
var a int8

var b int32

c := a + b
```

비록, `int32`의 길이가 `int8`보다 길고 `int` 타입과 동일하지만 그 타입간에 값을 할당 할 수는 없습니다. ( ***만약 c라면 여기에는 int 타입으로 선언 될 것입니다.*** )

실수형 타입(Float type)은 `float32`와 `float64`타입을 가지고 있고 `float`타입은 없습니다. 만약 간결한 구문을 사용할 경우 기본적으로 `float64`가 기본 타입이됩니다.

이게 다가 아닙니다! Go는 복소수도 지원합니다. `complex128`(64 비트 실수와 64 비트 허수 부분을 가지고 있음)이 기본 타입입니다. 더 작은 타입이 필요하다면, `complex64`(32 비트 실수와 32 비트 허수 부분을 가짐)를 사용하세요. 형태는 `RE + IMi`이며, `RE`는 실수 부분, `IM`은 허수 부분이고, 마지막 `i`는 허수입니다. 복소수를 사용하는 예제를 살펴봅시다.

```go
var c complex64 = 5+5i
// 출력값: (5+5i)
fmt.Printf("Value is: %v", c)
```

### 문자열(String)

앞 장에서 언급 한 바와 같이 Go 문자열은 모두`UTF-8` 코드가 채용되고 있습니다. 문자열은 쌍 따옴표 (` ""`) 또는 백틱 (``````````)로 둘러싸인되는 것으로 정의하며 타입은 `string`입니다.

```go
// 예제 코드
var frenchHello string  // 문자열을 정의하는 기본적인 형태
var emptyString string = ""  // 빈 문자열로 string 타입 변수 정의
func test() {
    no, yes, maybe := "no", "yes", "maybe"  // 간략한 구문으로 정의
    japaneseHello := "Ohaiou"
    frenchHello = "Bonjour"  // 값을 할당하는 기본적인 형태
}
```

문자열 값을 인덱스로 변경하는 것은 불가능합니다. 다음 코드를 컴파일 할 때 오류가 발생합니다.

```go
var s string = "hello"
s[0] = 'c'
```

문자열의 한 문자를 정말로 변경하고 싶다면, 다음 코드를 시도해보세요.

```go
s := "hello"
c := []byte(s)  // string 타입을 []byte 타입으로 변환합니다.
c[0] = 'c'
s2 := string(c)  // 다시 string 타입으로 변환합니다.
fmt.Printf("%s\n", s2)
```
	
`+` 연산자를 사용하여 두 개의 문자열을 결합합니다.

```go
s := "hello,"
m := " world"
a := s + m
fmt.Printf("%s\n", a)
```
	
또한 이런 것도 가능합니다.

```go
s := "hello"
s = "c" + s[1:] // 문자열 값을 인덱스로 변경할 수는 없지만, 값은 얻을 수 있습니다.
fmt.Printf("%s\n", s)
```
	
여러줄을 포함한 문자열을 정의하고 싶다면 어떻게 해야할까요?

```go
m := `hello
world`
```
    
``` ` ```는 문자열의 어떤 문자도 이스케이프하지 않습니다.

### 에러 타입

Go는 에러 메시지를 다루기 위해 하나의 `error` 타입을 가지고 있습니다. 오류를 처리하는`errors` 패키지도 있습니다.

```go
err := errors.New("emit macho dwarf: elf header corrupted")
if err != nil {
    fmt.Print(err)
}
```
	
### 기본 데이터 구조

다음 그림은 [Russ Cox 's Blog](http://research.swtch.com/)의 [Go data structure](http://research.swtch.com/godata)에 대한 글에서 가져온 것입니다. 보시다시피 Go는 메모리 블록을 사용하여 데이터를 저장합니다.

![](images/2.2.basic.png?raw=true)

Figure 2.1 Go 기본 데이터 구조

## 몇가지 기술

### 그룹으로 정의하기

만약 여러분이 여러개의 상수, 변수, 혹은 패키지를 임포트 하고싶다면, 그룹 형식을 사용할 수 있습니다.

기본 형식.

```go
import "fmt"
import "os"

const i = 100
const pi = 3.1415
const prefix = "Go_"

var i int
var pi float32
var prefix string
```

그룹 형식.

```go
import(
    "fmt"
    "os"
)

const(
    i = 100
    pi = 3.1415
    prefix = "Go_"
)

var(
    i int
    pi float32
    prefix string
)
```
	
상수 `iota`의 값을 지정하지 않으면 `const ()` 그룹의 상수 값의 첫 번째 값은 `0`이됩니다. 상수가 명시 적으로 값을 지정하지 않으면 그 값은 마지막 값과 동일하게 할당됩니다. 마지막 상수의 값이 `iota`이면 할당되지 않은 상수 값은 `iota`입니다.

### iota enumerate

Go는 `iota`라는 키워드가 있습니다. 이 키워드는 `enum`을 선언 할 때 사용됩니다. 이 기본값은 0부터 시작하며 순차적 1이 추가됩니다 :

```go
const(
    x = iota  // x == 0
    y = iota  // y == 1
    z = iota  // z == 2
    w  // 상수 이름 다음에 표현식이 없으면 마지막 표현식을 사용합니다.
    // 그래서 암시 적으로 w = iota를 말하고 있습니다. 따라서 w == 3이고, y와 z는 모두 "= iota"를 생략 할 수 있습니다.
)

const v = iota // iota가 `const` 키워드를 다시 만난다면, iota가 `0`로 초기화됩니다. 그러므로 v = 0입니다.

const ( 
  e, f, g = iota, iota, iota //  iota의 값은 한 행에서 동일하므로 e=0, f=0, g=0
)
```

### 몇가지 규칙

Go는 몇몇 기본 동작이 있기 때문에 간결합니다.

- 대문자로 시작하는 변수는 해당 변수를 외부에서도 쓸 것임을 의미합니다.
- 동일한 규칙이 함수와 상수에 적용되며 `public`또는 `private` 키워드가 Go에는 없습니다.

## array, slice, map

### array

`array`는 배열입니다. 우리는 다음과 같이 정의합니다.

```go
var arr [n]type
```
	
`[n] type`에서 `n`은 배열의 길이이고 `type`은 내부 요소의 타입입니다. 다른 언어들처럼, 우리는 `[]`를 사용하여 배열 내에서 요소 값을 가져 오거나 설정합니다.

```go
var arr [10]int  // arr은 [10]int 타입 배열
arr[0] = 42      // 배열은 0부터 시작합니다.
arr[1] = 13      // 요소에 값을 할당합니다.
fmt.Printf("The first element is %d\n", arr[0])  
// 요소 값 42를 반환합니다.
fmt.Printf("The last element is %d\n", arr[9]) 
// 이 배열의 10 번째 요소의 기본값을 반환하며 값은 0입니다.
```
	
length는 배열 타입의 일부이기 때문에 `[3]int`와 `[4]int`는 다른 타입이므로 배열의 길이를 변경할 수 없습니다. 배열을 인수로 사용하면 함수는 레퍼런스 대신 복사본(copy)을 가져옵니다! 레퍼런스를 사용하려면 `slice`를 사용하는 것이 좋고 나중에 이 내용을 다룹니다.

배열을 정의 할 때`: =`를 사용할 수 있습니다.

```go
a := [3]int{1, 2, 3} // 3개의 원소로 구성된 int 배열을 선언

b := [10]int{1, 2, 3} 
// 첫 요소부터 3번째 요소까지 값이 할당된 길이가 총 10인 int 배열을 선언합니다.
// 첫 요소부터 3번쨰 요소를 제외한 나머지는 기본값 0을 사용합니다.

c := [...]int{4, 5, 6} // 길이를 미리 설정하는 대신  `...`을 사용할 수 있고 Go가 길이를 자동으로 계산합니다.
```

배열을 배열의 요소로 사용할 수 있습니다. 다음 예제를 살펴봅시다.

```go
// 이차원 배열을 하나 선언합니다. 이 배열은 두 개의 배열을 요소로하고 각 배열에는 4 개의 int 타입의 요소가 포함되어 있습니다.
doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}

// 선언은 다음과 같이 보다 간결하게 작성할 수 있습니다.
easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
```
	
배열 기본 데이터 구조:

![](images/2.2.array.png?raw=true)

Figure 2.2 다차원 배열 매핑 관계

### slice

많은 경우에, 배열 타입은 좋은 선택이 될 수 없습니다 예를 들어 우리가 배열을 정의할 때 이 배열이 얼마만큼의 길이를 가져야 할지 모르기 때문입니다. 따라서 "동적 배열(Dynamic array)"이 필요합니다. 이것을 Go에서 `slice`라고 부릅니다.

`slice`는 실제로 동적 배열이 아닙니다. 레퍼런스 타입입니다. `slice`는 선언이 `array`와 비슷하지만 길이가 필요없는 기본 `array`를 가리킵니다.

```go
// 배열을 정의하는 것과 같지만 이번에는 길이를 제외합니다.
var fslice []int
```

우리는 `slice`를 정의 하고 데이터를 초기화 할 수 있습니다.

```go
slice := []byte {'a', 'b', 'c', 'd'}
```

`slice`는 기존 슬라이스 나 배열을 재정의 할 수 있습니다. `slice`는 슬라이스 할 때 `array[i:j]`를 사용합니다. 여기서`i`는 시작 인덱스이고 `j`는 끝 인덱스입니다. 그러나 `array[j]`는 슬라이스의 길이 때문에 슬라이스되지 않습니다. 길이는 `j-i`입니다.

```go
// 10개의 원소를 가진 바이트 타입의 배열을 정의합니다.
var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

// byte 타입의 두 슬라이스를 정의합니다.
var a, b []byte

// 'a'는 배열 ar에서 3 ~ 5 번째 원소를 가리 킵니다.
a = ar[2:5]
// 이제 'a'는 ar[2], ar[3] 및 ar[4]를 원소로 가지고 있습니다.

// 'b'는 배열 ar의 또 다른 슬라이스입니다.
b = ar[3:5]
// 이제 'b'는 ar[3] 및 ar[4]를 원소로 가지고 있습니다.
```
	
`slice`와 배열은 선언시에 구분되므로 주의하세요. 배열을 선언 할 때 괄호 안에 배열의 길이를 명시하거나 `...`을 사용해 자동으로 길이를 계산합니다. 그러나 `slice`를 선언 할 때는 중괄호에 문자가 없습니다.

기본 데이터 구조:

![](images/2.2.slice.png?raw=true)

Figure 2.3 슬라이스와 배열 간의 통신

슬라이스에는 몇 가지 편리한 용법이 있습니다.

- `slice`는 0 기반이고, `ar[:n]`은 `ar[0:n]`과 같습니다.
- `slice`의 두 번째 인덱스가 생략되면 슬라이스의 길이를 자동으로 넣어줍니다. `ar[n:]`은 `ar[n:len(ar)]`과 같습니다.
- `ar[:]`을 사용하여 전체 배열을 의미합니다. 이유는 위 두 문장에서 알 수 있습니다.

`slice`에 관한 더 많은 예제들.

```go
// 배열을 정의합니다.
var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
// 2개의 슬라이스를 정의합니다.
var aSlice, bSlice []byte

// 편리한 용법들
aSlice = array[:3] // aSlice = array[0:3]이고 aSlice는 a,b,c를 요소로 갖습니다.
aSlice = array[5:] // aSlice = array[5:10]이고 aSlice는 f,g,h,i,j를 요소로 갖습니다.
aSlice = array[:]  // aSlice = array[0:10]이고 aSlice는 array의 모든 요소를 갖습니다.

// 슬라이스에서 슬라이스하기
aSlice = array[3:7]  // aSlice는 d,e,f,g를 요소로 갖고，len=4，cap=7가 됩니다.
bSlice = aSlice[1:3] // bSlice는 aSlice[1], aSlice[2]를 가지고 있으므로 요소 e,f를 가지고 있는 것이 됩니다.
bSlice = aSlice[:3]  // bSlice는 aSlice[0], aSlice[1], aSlice[2]를 가지고 있으므로 요소 d,e,f를 가지고 있는 것이 됩니다.
bSlice = aSlice[0:5] // 슬라이스가 cap의 범위내에서 확장 될 수 있습니다. 이제 bSlice에는 d, e, f, g, h가 포함됩니다.
bSlice = aSlice[:]   // bSlice 이제 aSlice와 같은 요소인 d,e,f,g를 가지게됩니다. 
```

`slice`는 레퍼런스 타입이므로 어떤 변경도 같은 슬라이스나 배열을 가리키는 다른 변수에 영향을 미칩니다.
예를 들어 위의 `aSlice`나 `bSlice`의 경우 `aSlice`에서 요소의 값을 변경하면 `bSlice`도 변경됩니다.

개념적으로는 `slice`는 구조입니다. 이 구조체에는 3 개의 요소가 포함되어 있습니다:

- 하나는 포인터입니다. 배열 중의 `slice`가 나타내는 시작 위치를 가리킵니다.
- `slice`의 길이입니다.
- 나머지 하나는 용량(Capacity)입니다, 시작 인덱스에서 슬라이스의 끝 인덱스까지의 길이를 나타냅니다.

```go
Array_a := [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
Slice_a := Array_a[2:5]
```

위의 코드의 기본 데이터 구조는 다음과 같습니다.

![](images/2.2.slice2.png?raw=true)

Figure 2.4 슬라이스의 배열 정보

슬라이스에 대한 몇 가지 내장 함수가 있습니다.

- `len`은 `slice`의 길이를 얻습니다.
- `cap`는 `slice`의 최대 길이(용량)를 얻습니다.
- `append`는 하나 이상의 요소를 `slice`에 추가하고, `slice`를 반환합니다.
- `copy`는 하나의 슬라이스에서 다른 슬라이스로 요소를 복사하고 복사 된 요소의 수를 반환합니다.

주의사항 : `append`는 `slice`가 가리키는 배열을 변경하고 같은 배열을 가리키는 다른 슬라이스에 영향을 미칩니다.
또한, 슬라이스 (`(cap-len) == 0`)를 위한 길이가 충분하지 않으면, `append`는 이 슬라이스에 대한 새로운 배열을 반환합니다.
이 경우 이전 배열을 가리키는 다른 슬라이스가 영향을 받지 않습니다.

### map

`map`은 파이썬에서 딕셔너리처럼 동작합니다. 맵을 정의할 땐 `map[keyType]valueType` 형식을 사용하세요.

몇 가지 코드를 살펴 보겠습니다. `map`의 `set`과 `get` 값은 `slice`와 비슷하지만 차이점이 있습니다. `slice`의 인덱스는 무조건 `int`타입인 반면에 `map`은 그 이상을 사용할 수 있습니다 : 예를 들어 `int`,`string` 또는 원하는 것을 선택해 사용할 수 있고. 또한 `==`와 `!=`를 사용하여 값을 비교할 수 있습니다.

```go
// 문자열을 key의 타입으로 사용하고, int를 값의 타입으로 사용하고, `make`를 사용하여 초기화합니다.
var numbers map[string] int
// map을 정의하는 또 다른 방법
numbers := make(map[string]int)
numbers["one"] = 1  // key로 값을 할당합니다.
numbers["ten"] = 10 
numbers["three"] = 3

fmt.Println("The third number is: ", numbers["three"]) // 값을 얻습니다.
// 출력: The third number is: 3
```

여러분이 map을 쓰면서 알아야 할 것들.

- `map`은 순서가 보장이안됩니다. `map`을 출력 할 때마다 다른 결과를 얻습니다. `index`로 값을 얻는 것은 불가능하고, `key`를 사용해서 얻을 수 있습니다.
- `map`에는 고정 된 길이가 없습니다. 이것은 `slice`와 같은 레퍼런스 타입입니다.
- `len`도 `map`에서 동작합니다. `len`은 map이 얼마나 많은 `key`를 가지고 있는지 반환합니다.
- `map`을 통해 값을 변경하는 것은 아주 쉽습니다. 단순히 `numbers["one"] = 11`을 사용하여 `key`의 값을 `11`으로 변경하세요.

`key:val` 형식을 사용하여 맵의 값을 초기화 할 수 있으며 `map`에는 `key`가 있는지 확인하는 내장 메소드가 있습니다.

`map`에서 원소를 지우려면 `delete`를 사용하세요.

```go
// map을 초기화합니다.
rating := map[string]float32 {"C":5, "Go":4.5, "Python":4.5, "C++":2 }
// map에는 두 개의 반환 값이 있습니다. 두 번째 반환 값에 대해 키가 존재하지 않으면 
// 'ok'는 false를 반환합니다. 그렇지 않으면 true를 리턴합니다.
csharpRating, ok := rating["C#"]
if ok {
        fmt.Println("C# is in the map and its rating is ", csharpRating)
} else {
        fmt.Println("We have no rating associated with C# in the map")
}

delete(rating, "C")  // key "c"가 있는 요소 삭제
```

위에서 말했듯이 `map`은 레퍼런스 타입입니다. 만약 두 개의 `map`이 동일한 기본 데이터를 가리키면, 어떤 변화라도 양쪽 모두에 영향을 미칩니다.

```go
m := make(map[string]string)
m["Hello"] = "Bonjour"
m1 := m
m1["Hello"] = "Salut"  // 이제 m["hello"] 의 값은 Salut입니다.
```
	
### make, new

`make`는 `map`, `slice`, `channel`과 같은 내장 모델에 대한 메모리 할당을 수행하는 반면, `new`는 타입의 메모리 할당을위한 것입니다.

`new(T)`는 타입 `T`의 메모리에 0 값을 할당하고, 메모리 주소를 반환합니다. 메모리 주소는 `*T` 타입의 값입니다. Go의 정의에 따라 포인터는 `T`의 0 값을 가리키는 포인터를 반환합니다.

> `new` 포인터를 반환합니다.

내장 함수`make(T, args)`는 `new(T)`와 다른 목적을 가지고 있습니다. `make`는 `slice`, `map`, `channel`에 사용될 수 있으며, 초기 값을 갖는 `T` 타입을 반환합니다.
왜냐하면 이러한 세 가지 타입의 기본 데이터가 초기화되기 전에 초기화 되어야하기 때문입니다. 예를 들어,`slice`는 기본 `array`, 길이 및 용량을 가리키는 포인터를 포함합니다. 
데이터가 초기화되기 전에 `slice`는 `nil`이므로, `slice`, `map`과 `channel`에 대해서 `make`는 기본 데이터를 초기화하고 적당한 값을 할당합니다.

> `make` 0이 아닌 값을 반환합니다.

다음 그림은 `new`와 `make`가 어떻게 다른지 보여줍니다.

![](images/2.2.makenew.png?raw=true)

Figure 2.5 make와 new의 기본 메모리 할당

0 값은 빈 값을 의미하지 않습니다. 대부분의 경우 변수가 기본값으로 사용합니다. 다음은 일부 영 (zero) 값 목록입니다.

	int     0
	int8    0
	int32   0
	int64   0
	uint    0x0
	rune    0 // the actual type of rune is int32
	byte    0x0 // the actual type of byte is uint8
	float32 0 // length is 4 byte
	float64 0 //length is 8 byte
	bool    false
	string  ""
	
## 링크

- [목차](preface.md)
- 이전 글: ["Hello, Go"](02.1.md)
- 다음 글: [제어문과 함수](02.3.md)
