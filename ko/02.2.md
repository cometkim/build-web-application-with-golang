# 2.2 Go 기초

이번 장에서는, 기본 타입의 상수와 변수를 정의하는 방법 및 Go 프로그래밍에서의 몇 가지 기술에 대해 알려드리려고 합니다.

## 변수 정의

Go에서 변수를 정의하는 데 사용할 수 있는 다양한 형식의 구문이 있습니다.

`var` 키워드는 변수를 정의하는 기본 형식입니다. Go는 변수명 뒤에 변수 타입을 적습니다.

```go
// 이름이 "variableName"이고 타입이 "type"인 변수를 정의합니다.
var variableName type
```

여러개의 변수 정의하기

```go
// 타입이 "type"인 세 개의 변수를 정의합니다.
var vname1, vname2, vname3 type
```
	
초기값을 가진 변수 정의하기

```go
// 이름이 “variableName”, 타입이 "type" 그리고 값이 "value"인 변수를 정의합니다.
var variableName type = value
```
	
여러개의 변수를 초기값과 함께 정의하기
```go
/*
"type" 타입을 가진 3개의 변수를 정의하고 그 값을 초기화합니다.
vname1 = v1, vname2 = v2, vname3 = v3
*/
var vname1, vname2, vname3 type = v1, v2, v3
```
	
변수를 정의하는 것이 너무 지루하다고 생각하세요? 걱정마세요, 왜냐하면 Go 팀도 이 문제를 발견했기 때문입니다. 따라서 초기값을 사용하여 변수 타입을 생략한 채 변수를 정의할 수 있습니다. 코드는 다음과 같이 쓸 수 있습니다.

```go

/*
타입을 명시하지 않은 3개의 변수를 정의하고 그 값을 초기화합니다.
vname1 is v1，vname2 is v2，vname3 is v3
*/
var vname1, vname2, vname3 = v1, v2, v3
```

네, 아직도 충분히 간단하지 않다는걸 알고 있습니다. 이를 고치는 방법을 살펴봅시다.

```go
/*
"var" 키워드를 사용하지 않고 타입을 명시하지 않은 3개의 변수를 정의하고 그 값을 초기화합니다.
vname1 is v1，vname2 is v2，vname3 is v3
*/
vname1, vname2, vname3 := v1, v2, v3
```
	
이제야 좀 보기 좋아졌군요. `:=`를 사용하여 `var`과 `type`을 대체했습니다. 이것을 간결한 구문(brief statement)이라고합니다. 하지만, 한 가지 제한이 있습니다. 이 구문은 함수 내부에서만 사용할 수 있고 함수 밖에서 사용하려고하면 컴파일 오류가 발생합니다. 그러므로 일반적으로 전역 변수를 정의하기 위해선 `var` 키워드를 사용합니다.

`_`(공백)은 특별한 변수 이름입니다. 이것에 주어진 값은 무시됩니다. 예를 들어 `b`에 `35`를 주고 `34`를 버립니다.( ***이 예제는 단순히 어떻게 작동하는지 보여주기위해 작성하였습니다. 쓸데 없이 보일지 몰라도 함수의 반환값을 얻을 땐 종종 이 기호를 사용합니다.*** )

```go
_, b := 34, 35
```
	
프로그램에서 정의한 변수를 사용하지 않으면 컴파일러에서 컴파일 오류를 발생시킵니다. 다음 코드를 컴파일하고 무슨 일이 일어나는지 보세요.

```go
package main

func main() {
    var i int
}
```
	
## 상수 (Constants)

상수는 컴파일시에 결정되는 값이며 런타임중에 변경할 수 없습니다. Go에서는 숫자, 부울(boolean) 또는 문자열 타입을 상수로 사용할 수 있습니다.

다음과 같이 상수를 정의하세요.

```go
const constantName = value
// 필요한 경우 상수 타입을 지정할 수 있습니다.
const Pi float32 = 3.1415926
```

더 많은 예제.

```go
const Pi = 3.1415926
const i = 10000
const MaxThread = 10
const prefix = "astaxie_"
```

## 기본 타입

### 부울 (Boolean)

Go에서는 부울 타입의 변수를 정의하기 위해 `bool`을 사용합니다. 값은 `true` 또는 `false` 만 가능하고 `false`가 기본값입니다. ( ***여러분은 변수의 타입을 숫자에서 부울로 부울에서 숫자로 변환 할 수 없습니다.*** )

```go
// 예제 코드
var isActive bool  // 전역 변수
var enabled, disabled = true, false  // 변수의 타입을 생략
func test() {
    var available bool  // 지역 변수
    valid := false      // 변수의 간략한 선언
    available = true    // 변수에 값 할당
}
```
	
### 숫자 타입

정수형 타입 (Integer type)에는 부호있는 정수 타입과 부호없는 정수 타입이 모두 포함됩니다. Go는 `int`와 `uint`를 동시에 가지며 길이는 같지만 특정 길이는 운영체제에 따라 다릅니다. 32 비트 운영 체제에서는 32 비트를, 64 비트 운영 체제에서는 64 비트를 사용합니다. Go는 또한 `rune`, `int8`, `int16`, `int32`, `int64`, `byte`, `uint8`, `uint16`, `uint32`, `uint64`과 같은 특정한 길이를 가진 타입을 가지고 있습니다. `rune`은 `int32`의 별명이고 `byte`는 `uint8`의 별칭입니다.

이들 타입간 할당은 불가능하다는 것을 알아야합니다. 다음 연산은 컴파일 오류를 발생시킵니다.

```go
var a int8

var b int32

c := a + b
```

비록, `int32`가 `int8`보다 긴 길이를 갖고 `int`와 동일한 타입을 가지지만, 이들간의 값 할당은 불가능합니다. ( ***위 코드에서 c는 int 타입으로 단언됩니다.*** )

실수형 타입 (Float type)은 `float32`와 `float64`타입을 가지며 `float`타입은 없습니다. 간결한 구문을 사용할 경우 후자가 기본 타입으로 사용됩니다.

이게 다가 아닙니다! Go는 복소수도 지원합니다. `complex128` (64 비트 실수와 64 비트 허수 부분을 가지고 있음)이 기본 타입입니다. 더 작은 타입이 필요하다면, `complex64`(32 비트 실수와 32 비트 허수 부분을 가짐)를 사용하세요. 형태는 `RE + IMi`이고 `RE`는 실수 부분, `IM`은 허수 부분이며 마지막 `i`는 허수입니다. 복소수를 사용하는 예제를 살펴봅시다.

```go
var c complex64 = 5+5i
// 출력값: (5+5i)
fmt.Printf("Value is: %v", c)
```

### 문자열(String)

앞 장에서 언급 한 바와 같이 Go는 UTF-8 문자열 셋을 사용한다고 했습니다. 문자열은 쌍 따옴표 (` ""`) 또는 백틱 (``````)으로 표현됩니다.

```go
// 예제 코드
var frenchHello string  // 문자열을 정의하는 기본적인 형태
var emptyString string = ""  // 빈 문자열로 string 타입 변수 정의
func test() {
    no, yes, maybe := "no", "yes", "maybe"  // 간략한 구문으로 정의
    japaneseHello := "Ohaiou"
    frenchHello = "Bonjour"  // 값을 할당하는 기본적인 형태
}
```

문자열 값을 인덱스로 변경하는 것은 불가능합니다. 다음 코드는 컴파일시 오류를 발생시킵니다.

```go
var s string = "hello"
s[0] = 'c'
```

문자열의 한 문자를 정말로 변경하고 싶다면, 다음 코드를 시도해보세요.

```go
s := "hello"
c := []byte(s)  // string 타입을 []byte 타입으로 변환합니다.
c[0] = 'c'
s2 := string(c)  // 다시 string 타입으로 변환합니다.
fmt.Printf("%s\n", s2)
```
	
`+` 연산자를 사용하여 두 개의 문자열을 결합합니다.

```go
s := "hello,"
m := " world"
a := s + m
fmt.Printf("%s\n", a)
```
	
또한 이런 것도 가능합니다.

```go
s := "hello"
s = "c" + s[1:] // 문자열 값을 인덱스로 변경할 수는 없지만, 값은 얻을 수 있습니다.
fmt.Printf("%s\n", s)
```
	
여러줄을 포함한 문자열을 정의하고 싶다면 어떻게 해야할까요?

```go
m := `hello
world`
```
    
``` ` ```는 문자열의 어떤 문자도 이스케이프하지 않습니다.

### 에러 타입

Go는 에러 메시지를 다루기 위해 하나의 `error` 타입을 가지고 있습니다.  에러를 처리하기 위한 `errors` 패키지가 있습니다.

```go
err := errors.New("emit macho dwarf: elf header corrupted")
if err != nil {
    fmt.Print(err)
}
```
	
### 기본 데이터 구조

다음 그림은 [Russ Cox 's Blog](http://research.swtch.com/)의 [Go data structure](http://research.swtch.com/godata)에 대한 글에서 가져온 것입니다. 보시다시피 Go는 메모리 블록을 사용하여 데이터를 저장합니다.

![](images/2.2.basic.png?raw=true)

Figure 2.1 Go 기본 데이터 구조

## 몇가지 기술

### 그룹으로 정의하기

만약 여러분이 여러개의 상수, 변수 혹은 패키지를 임포트 하고싶다면, 그룹 형식을 사용할 수 있습니다.

기본 형식.

```go
import "fmt"
import "os"

const i = 100
const pi = 3.1415
const prefix = "Go_"

var i int
var pi float32
var prefix string
```

그룹 형식.

```go
import(
    "fmt"
    "os"
)

const(
    i = 100
    pi = 3.1415
    prefix = "Go_"
)

var(
    i int
    pi float32
    prefix string
)
```
	
상수 `iota`의 값을 지정하지 않으면 `const ()` 그룹의 첫 번째 상수 값은 `0`이됩니다. 뒤에 따라오는 상수들에 명시적으로 값을 할당하지 않으면, 마지막값과 동일한 값을 갖게됩니다. 만약 마지막 상수값이 `iota`라면, 그 이후의 할당 되지않은 상수값들 또한 `iota`를 값으로 갖습니다.

### iota enumerate

Go에는 `iota`라는 키워드가 있으며, 이는 `enum`을 생성할 때 사용됩니다. 이는 `0`부터 시작해 `1`씩 증가합니다. :

```go
const(
    x = iota  // x == 0
    y = iota  // y == 1
    z = iota  // z == 2
    w  // 상수명 다음에 표현식이 없으면 마지막 표현식을 사용합니다.
    // 즉 암시적으로 w = iota를 뜻합니다. 따라서 w == 3이며 y와 z 또한 "= iota"를 생략할 수 있습니다.
)

const v = iota // iota가 const 키워드를 만나면, 0으로 초기화되므로, v = 0입니다.

const ( 
  e, f, g = iota, iota, iota //  iota는 한 라인에서 같은 값을 가지므로 e=0, f=0, g=0입니다.
)
```

### 몇가지 규칙

Go가 간결한 이유는 다음과 같은 기본적인 동작을 가지고 있기 때문입니다.

- 대문자로 시작하는 모든 변수는 외부에 노출됨을 의미하며, 그 외의 경우는 프라이빗 변수입니다.
- 함수와 상수에도 동일한 규칙이 적용되며, Go에는 `public` 또는 `private` 키워드가 존재하지 않습니다.

## array, slice, map

### array

`array`는 배열입니다. 다음과 같이 정의합니다.

```go
var arr [n]type
```
	
`[n]type`에서 `n`은 배열의 길이이고 `type`은 원소의 타입입니다. 다른 언어에서와 같이, 배열의 원소값을 가져오거나 설정하기 위해 `[]`를 사용합니다.

```go
var arr [10]int  // arr은 [10]int 타입의 배열
arr[0] = 42      // 배열은 0부터 시작합니다.
arr[1] = 13      // 원소에 값을 할당합니다.
fmt.Printf("The first element is %d\n", arr[0])  
// 원소값 42를 반환합니다.
fmt.Printf("The last element is %d\n", arr[9]) 
// 이 배열의 10번째 원소의 기본값을 반환하며 값은 0입니다.
```
	
length는 배열 타입의 일부이기 때문에 `[3]int`와 `[4]int`는 다른 타입이며, 배열의 길이는 변경할 수 없습니다. 배열을 인수로 사용하면 함수는 레퍼런스 대신 복사본(copy)을 가져옵니다! 레퍼런스를 사용하기 위해선 `slice`를 사용하는 것이 좋습니다. 이는 나중에 살펴보겠습니다.

배열을 정의 할 때`:=`를 사용할 수 있습니다.

```go
a := [3]int{1, 2, 3} // 3개의 원소로 구성된 int 배열을 선언

b := [10]int{1, 2, 3} 
// 첫 세 개의 원소에 값을 할당한 길이가 10인 int형 배열을 선언합니다.
// 첫 요소부터 3번쨰 요소를 제외한 나머지는 기본값 0을 사용합니다.

c := [...]int{4, 5, 6} // 길이 매개변수로 …를 대신 사용하면 Go가 길이를 계산해줍니다.
```

배열을 배열의 원소로 사용할 수 있습니다. 어떻게 하는지 살펴봅시다.

```go
// 이차원 배열을 하나 선언합니다. 이 배열은 두 개의 배열을 원소로하고 각 배열은 4개의 원소를 가집니다.
doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}

// 선언은 다음과 같이 보다 간결하게 작성할 수 있습니다.
easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
```
	
배열 기본 데이터 구조:

![](images/2.2.array.png?raw=true)

Figure 2.2 다차원 배열 매핑 관계

### slice

많은 경우, 배열 타입은 좋은 선택이 아닙니다. 예를 들어 배열을 정의할 때 이 배열이 얼마나 길어질지 알 수 없는 경우가 있습니다. 따라서 "동적 배열(Dynamic array)"이 필요합니다. 이것을 Go에선 `slice`라고 부릅니다.

`slice`는 실제로 동적 배열이 아닙니다. 레퍼런스 타입입니다. `slice`는 `array`와 비슷한 선언을 갖는 기본 `array`를 가리키지만 길이가 필요없습니다.

```go
// 배열을 정의하는 것과 같지만 이번에는 길이를 제외합니다.
var fslice []int
```

우리는 `slice`를 정의 하고 데이터를 초기화 할 수 있습니다.

```go
slice := []byte {'a', 'b', 'c', 'd'}
```

`slice`는 기존 슬라이스나 배열을 재정의 할 수 있습니다. `slice`는 슬라이스 할 때 `array[i:j]`를 사용합니다. 여기서`i`는 시작 인덱스이고 `j`는 끝 인덱스입니다. 그러나 `array[j]`는 슬라이스의 길이 때문에 슬라이스되지 않습니다. 길이는 `j-i`입니다.

```go
// 10개의 원소를 가진 바이트 타입의 배열을 정의합니다.
var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

// byte 타입의 두 슬라이스를 정의합니다.
var a, b []byte

// 'a'는 배열 ar의 3 ~ 5 번째 원소를 가리킵니다.
a = ar[2:5]
// 이제 'a'는 ar[2], ar[3] 및 ar[4]를 원소로 가지고 있습니다.

// 'b'는 배열 ar의 또 다른 슬라이스입니다.
b = ar[3:5]
// 이제 'b'는 ar[3] 및 ar[4]를 원소로 가지고 있습니다.
```
	
`slice`와 `array` 정의간의 차이점에 주목하세요. Go가 길이를 계산해줄 때에는 `[…]`를 사용하지만, 슬라이스만 정의할 때에는 `[]`를 사용합니다.

배열과 슬라이스의 기본 데이터 구조:

![](images/2.2.slice.png?raw=true)

Figure 2.3 슬라이스와 배열 간의 통신

슬라이스에는 몇 가지 편리한 연산들이 있습니다.

- `slice`는 인덱스가 0부터 시작하며, `ar[:n]`은 `ar[0:n]`과 같습니다.
- 두 번째 인덱스가 생략되어 있으면 `slice`의 길이를 대신 사용합니다. `ar[n:]`은 `ar[n:len(ar)]`과 같습니다.
- 전체 배열을 슬라이스 하기위해 `ar[:]`를 사용할 수 있으며, 원리는 위 두 문장에서 알 수 있습니다.

`slice` 관련 추가 예제들

```go
// 배열을 정의합니다.
var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
// 2개의 슬라이스를 정의합니다.
var aSlice, bSlice []byte

// 편리한 연산들
aSlice = array[:3] // aSlice = array[0:3]이고 aSlice는 a,b,c를 원소로 갖습니다.
aSlice = array[5:] // aSlice = array[5:10]이고 aSlice는 f,g,h,i,j를 원소로 갖습니다.
aSlice = array[:]  // aSlice = array[0:10]이고 aSlice는 array의 모든 원소를 갖습니다.

// 슬라이스에서 슬라이스하기
aSlice = array[3:7]  // aSlice는 d,e,f,g를 원소로 갖고，len=4，cap=7이 됩니다.
bSlice = aSlice[1:3] // bSlice는 aSlice[1], aSlice[2]를 포함하므로, 원소 e, f를 갖습니다.
bSlice = aSlice[:3]  // bSlice는 aSlice[0], aSlice[1], aSlice[2]를 포함하므로 원소 d,e,f를 갖습니다.
bSlice = aSlice[0:5] // 슬라이스는 cap의 범위내에서 확장 될 수 있습니다. 이제 bSlice는 d,e,f,g,h를 포함합니다.
bSlice = aSlice[:]   // bSlice는 aSlice와 동일한 원소들인 d,e,f,g를 갖습니다.
```

`slice`는 레퍼런스 타입이므로 변경시에 같은 슬라이스나 배열을 가리키는 다른 변수에 영향을 미칩니다.
예를 들어 위의 `aSlice`나 `bSlice`의 경우 `aSlice`에서 원소값을 변경하면 `bSlice`도 변경됩니다.

`slice`는 정의에 의한 구조체와 같으며 다음의 3 부분을 포함하고 있습니다:

- `slice`의 시작 지점을 가리키는 포인터. 배열 중의 `slice`가 나타내는 시작 위치를 가리킵니다.
- `slice`의 길이
- `slice`의 시작 인덱스부터 끝 인덱스까지의 길이를 나타내는 용량 (Capacity)

```go
Array_a := [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
Slice_a := Array_a[2:5]
```

위의 코드의 기본 데이터 구조는 다음과 같습니다.

![](images/2.2.slice2.png?raw=true)

Figure 2.4 슬라이스의 배열 정보

슬라이스를 위한 몇 가지 내장 함수들이 있습니다.

- `len`은 `slice`의 길이를 얻습니다.
- `cap`는 `slice`의 최대 길이(용량)를 얻습니다.
- `append`는 하나 이상의 원소를 `slice`에 추가하고, `slice`를 반환합니다.
- `copy`는 하나의 슬라이스에서 다른 슬라이스로 요소를 복사하고 복사된 요소의 수를 반환합니다.

주의사항 : `append`는 `slice`가 가리키는 배열을 변경하고 같은 배열을 가리키는 다른 슬라이스에 영향을 미칩니다.
또한, 슬라이스의 길이가 충분하지 않은 경우 (`(cap-len) == 0`), `append`는 이 슬라이스의 새로운 배열을 반환합니다.
이 경우 이전 배열을 가리키는 다른 슬라이스는 영향을 받지 않습니다.

### map

`map`은 파이썬에서 딕셔너리와 유사하게 동작합니다. 맵을 정의할 땐 `map[keyType]valueType` 형식을 사용하세요.

몇 가지 코드를 살펴 보겠습니다. `map`의 `set`과 `get`은 `slice`와 유사하지만 `slice`의 인덱스는 무조건 `int` 타입인 반면에 `map`은 그 이상을 사용할 수 있습니다 : 예를 들어 `int`,`string` 또는 원하는 것을 선택해 사용할 수 있고. 또한 값을 비교하기 위해 `==`와 `!=`를 사용할 수 있습니다.

```go
// key 타입으로 문자열을, 값 타입으로 int를 사용하고, 'make'로 초기화를 합니다.
var numbers map[string] int
// map을 정의하는 또 다른 방법
numbers := make(map[string]int)
numbers["one"] = 1  // key로 값을 할당합니다.
numbers["ten"] = 10 
numbers["three"] = 3

fmt.Println("The third number is: ", numbers["three"]) // 값을 얻습니다.
// 출력: The third number is: 3
```

여러분이 map을 쓰면서 알아야 할 것들.

- `map`에는 순서가 없습니다. `map`은 출력 할 때마다 다른 결과를 얻습니다. `index`로 값을 얻는 것은 불가능하며 `key`å를 사용해야만 합니다.
- `map`에는 고정 된 길이가 없습니다. 이것은 `slice`와 같은 레퍼런스 타입입니다.
- `len`도 `map`에서 동작합니다. `len`은 `map`이 가지고 있는 `key`의 갯수를 반환합니다.
- `map`을 통해 값을 변경하는 것은 아주 쉽습니다. one `key`의 값을 `11`로 변경하기 위해 단순히 `numbers["one"]=11`를 사용합니다.

`key:val` 형식을 사용하여 맵의 값을 초기화 할 수 있으며 `map`은 `key`의 존재 여부를 확인할 수 있는 내장 메서드를 가지고 있습니다.

`map`에서 원소를 지우려면 `delete`를 사용하세요.

```go
// map을 초기화합니다.
rating := map[string]float32 {"C":5, "Go":4.5, "Python":4.5, "C++":2 }
// map에는 두 개의 반환값이 있습니다. 두 번째 반환 값에 대해 키가 존재하지 않으면 
// 'ok'는 false를 반환합니다. 그렇지 않으면 true를 반환합니다.
csharpRating, ok := rating["C#"]
if ok {
        fmt.Println("C# is in the map and its rating is ", csharpRating)
} else {
        fmt.Println("We have no rating associated with C# in the map")
}

delete(rating, "C")  // "c" 키값을 가진 원소 삭제
```

위에서 말했듯이 `map`은 레퍼런스 타입입니다. 만약 두 개의 `map`이 동일한 기본 데이터를 가리킬때 변화가 생기면 양쪽 모두에 영향을 미칩니다.

```go
m := make(map[string]string)
m["Hello"] = "Bonjour"
m1 := m
m1["Hello"] = "Salut"  // 이제 m["Hello"] 의 값은 Salut입니다.
```
	
### make, new

`make`는 `map`, `slice`, `channel`과 같은 내장 모델에 대한 메모리 할당을 수행하는 반면, `new`는 타입 메모리 할당을 위한 것입니다.

`new(T)`는 타입 `T`의 메모리에 제로값을 할당하고, 메모리 주소를 반환합니다. 메모리 주소는 `*T` 타입의 값입니다. Go의 정의에 의해, 이는 T의 제로값을 가리키는 포인터를 반환합니다.

> `new`는 포인터를 반환합니다.

내장 함수`make(T, args)`는 `new(T)`와 다른 목적을 가지고 있습니다. `make`는 `slice`, `map`, `channel`에 사용될 수 있으며, 초기 값을 갖는 `T` 타입을 반환합니다.
왜냐하면 이러한 세 가지 타입의 기본 데이터가 초기화되기 전에 초기화 되어야하기 때문입니다. 예를 들어,`slice`는 기본 `array`, 길이 및 용량을 가리키는 포인터를 포함합니다. 
데이터가 초기화되기 전에 `slice`는 `nil`이므로, `slice`, `map`과 `channel`에 대해서 `make`는 기본 데이터를 초기화하고 적당한 값을 할당합니다.

> `make`는 제로값이 아닌 값을 반환합니다.

다음 그림은 `new`와 `make`가 어떻게 다른지 보여줍니다.

![](images/2.2.makenew.png?raw=true)

Figure 2.5 make와 new의 기본 메모리 할당

제로값은 빈 값을 의미하지 않습니다. 이는 대부분의 경우 변수가 기본값으로 사용하는 값입니다. 다음은 일부 제로값 목록입니다.

	int     0
	int8    0
	int32   0
	int64   0
	uint    0x0
	rune    0 // the actual type of rune is int32
	byte    0x0 // the actual type of byte is uint8
	float32 0 // length is 4 byte
	float64 0 //length is 8 byte
	bool    false
	string  ""
	
## 링크

- [목차](preface.md)
- 이전 글: ["Hello, Go"](02.1.md)
- 다음 글: [제어문과 함수](02.3.md)
