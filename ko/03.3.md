# 3.3 웹에서의 Go 동작 원리

우리는 이전 글에서 간단한 웹 서버를 만들기 위해 `net/http` 패키지를 사용하는 방법을 배웠고, 모든 작동 원리는 이 글의 첫 번째 절에서 이야기 할 내용과 같습니다.

## 웹 원리의 개념

Request: POST, GET, 쿠키 및 URL을 포함하여 사용자의 데이터를 요청합니다.

Response: 응답 데이터를 서버에서 클라이언트로 전송합니다.

Conn: 클라이언트와 서버 간의 연결.

Handler: 요청 처리 로직 및 응답 생성.

## http 패키지 작동 메커니즘

다음 그림은 Go 웹 서버의 작업 흐름을 보여줍니다.

![](images/3.3.http.png?raw=true)

Figure 3.9 http 작업 흐름

1. 특정 포트에서 클라이언트 요청을 대기하는 소켓을 만듭니다.
2. 클라이언트의 요청을 받아들입니다.
3. 요청을 처리하고 HTTP 헤더를 읽습니다. 요청에서 POST 메서드를 사용하는 경우 메시지 본문에서 데이터를 읽고 이를 핸들러로 전달합니다. 마지막으로 소켓은 응답 데이터를 클라이언트에 반환합니다.

다음 세 가지 질문에 대한 답변을 알게되면 Go에서 웹이 어떻게 작동하는지 쉽게 알 수 있습니다.

- 포트에서 수신을 어떻게 하나요?
- 클라이언트의 요청을 어떻게 받아들일까요?
- 핸들러를 어떻게 할당 하나요?

이전 글에서는 Go가 `ListenAndServe`를 사용해 서버 객체 `call net.Listen("tcp", addr)`를 초기화하여 TCP 리스너를 설정하고 특정 주소와 포트를 수신하는 것을 봤습니다.

이제 http 패키지의 소스 코드를 살펴 보겠습니다.

	//빌드 버전 go 1.1.2.
	func (srv *Server) Serve(l net.Listener) error {
		defer l.Close()
		var tempDelay time.Duration // 접속 실패시 대기 시간
		for {
			rw, e := l.Accept()
			if e != nil {
				if ne, ok := e.(net.Error); ok && ne.Temporary() {
					if tempDelay == 0 {
						tempDelay = 5 * time.Millisecond
					} else {
						tempDelay *= 2
					}
					if max := 1 * time.Second; tempDelay > max {
						tempDelay = max
					}
					log.Printf("http: Accept error: %v; retrying in %v", e, tempDelay)
					time.Sleep(tempDelay)
					continue
				}
				return e
			}
			tempDelay = 0
			c, err := srv.newConn(rw)
			if err != nil {
				continue
			}
			go c.serve()
		}
	}


포트 수신을 시작한 후 클라이언트 요청을 어떻게 받아들일까요? 소스 코드에서 클라이언트 요청을 처리하기 위해 `srv.Serve(net.Listener)`가 호출됨을 알 수 있습니다. 함수 본문에는 `for{}`이 있습니다. 요청을 받아들이고 새로운 연결을 생성 한 다음 새로운 goroutine을 시작하여 요청 데이터를 `go c.serve()` goroutine에 전달합니다. 이게바로 Go에서 높은 동시성을 지원하고 모든 goroutine이 독립적으로 동작하게하는 방법입니다.

특정 기능을 사용하여 요청을 처리하는 방법은 무엇일까요? `conn`는 처음에 `c.ReadRequest()`를 파싱 한 다음 대응하는 핸들러를 얻습니다: `handler := sh.srv.Handler`는 `ListenAndServe`를 호출 할 때 우리가 건네 준 두 번째 인자입니다. 우리가 `nil`을 통과했기 때문에 Go는 기본 핸들러 인`handler = DefaultServeMux`를 사용합니다. 그렇다면 `DefaultServeMux`는 여기서 어떤 일을 할까요? 특정 URL에 대한 핸들러 함수를 호출 할 수있는 라우터 변수입니다. 우리는 이미 이것을 설정했습니다! 우리는 `http.HandleFunc("/", sayhelloName)`을 사용했던 첫 번째 줄에서 이 작업을 수행했습니다. 이 기능을 사용하여 "/" 경로에 대한 라우터 규칙을 등록합니다. URL이 `/`이면 라우터는 `sayhelloName` 함수를 호출합니다. DefaultServeMux는 ServerHTTP를 호출하여 다른 경로에 대한 처리기 함수를 가져오고 이 경우에는 `sayhelloName`을 호출합니다. 마지막으로 서버는 데이터를 쓰고 클라이언트에 응답합니다.

자세한 작업 흐름:

![](images/3.3.illustrator.png?raw=true)

Figure 3.10 HTTP 요청 처리의 작업 흐름

이제는 여러분이 Go가 웹 서버를 어떻게 실행하는지 알아야한다고 생각합니다.

## 링크

- [목차](preface.md)
- 이전 글: [간단한 웹 서버 만들기](03.2.md)
- 다음 글: [Http 패키지 살펴보기](03.4.md)
