# Web 작동 원리

여러분이 브라우저를 실행할 때 마다, URL을 입력하고 enter를 누를 때 마다, 여러분은 여러분의 화면에 나타나는 아름다운 웹 페이지들을 볼 수 있습니다. 그러나 이러한 간단한 행동 뒤에 어떠한 일들이 일어나는지 알고 계신가요?

일반적으로 브라우저는 클라이언트입니다. URL을 입력하면 URL의 호스트 부분을 가져와 호스트의 IP 주소를 얻기 위해 DNS 서버로 보냅니다. 그런 다음 IP 주소에 연결하고 TCP 연결을 설정하도록 요청합니다. 브라우저는 연결을 통해 HTTP 요청을 보냅니다. 서버는 웹 페이지를 처리하고 웹 페이지를 구성하는 컨텐츠를 포함하는 HTTP 응답을 받습니다. 마지막으로 브라우저는 웹 페이지의 본문을 렌더링하고 서버와의 연결을 끊습니다.

![](images/3.1.web2.png?raw=true)

Figure 3.1 웹 사이트를 방문하는 사용자의 프로세스

HTTP 서버라고도하는 웹 서버는 HTTP 프로토콜을 사용하여 클라이언트와 통신합니다. 모든 웹 브라우저는 클라이언트라 할 수 있습니다.

We can divide the web's working principles into the following steps:

우리는 웹을 작동 원리를 다음 단계로 나눌 수 있습니다:

- 클라이언트는 TCP/IP 프로토콜을 사용하여 서버에 연결합니다.
- 클라이언트가 서버에 HTTP 요청 패키지를 보냅니다.
- 서버는 HTTP 응답 패키지를 클라이언트에 반환합니다. 요청 된 리소스에 동적 스크립트가 포함 된 경우 서버는 먼저 스크립트 엔진을 호출합니다.
- 클라이언트는 서버와의 연결을 끊고 HTML 렌더링을 시작합니다.

이는 HTTP의 간단한 작업 흐름입니다. 조심해야 할 것은 클라이언트와 서버 사이의 통신은 항상 연결되어있는 것은 아닙니다. 서버는 클라이언트에게 데이터를 보낸 후 클라이언트와의 연결을 끊고 다음 요청을 기다립니다.

## URL 및 DNS 확인

우리는 항상 URL을 사용하여 웹 페이지에 접근하지만, 여러분은 URL이 어떻게 작동하는지 알고 있나요?

The full name of a URL is Uniform Resource Locator. It's for describing resources on the internet and its basic form is as follows.

URL의 전체 이름은 `Uniform Resource Locator` 입니다. 이것은 인터넷상의 자원을 설명하기위한 것이며 기본형태는 다음과 같습니다. 

	scheme://host[:port#]/path/.../[?query-string][#anchor]
	scheme         기본 프로토콜 할당 (예를들어.. HTTP, HTTPS, FTP)
	host           HTTP 서버의 IP 또는 도메인 이름
	port#          기본 포트는 80이며 이 경우 생략 가능합니다.
			다른 포트를 사용하려면 포트를 지정해야합니다. 예를들면,
			http://www.cnblogs.com:8080/
	path           자원 경로
	query-string   서버에 전송될 데이터
	anchor         앵커

DNS는 `Domain Name System`의 약자입니다. 이는 컴퓨터 네트워크 서비스를위한 네이밍 시스템이며, 번역사처럼 도메인 이름을 실제 IP 주소로 변환합니다.

![](images/3.1.dns_hierachy.png?raw=true)

Figure 3.2 DNS 작동 원리

DNS의 작동 원리에 대해 더 자세히 이해하려면 다음과 같이 자세한 DNS 확인 프로세스를 살펴 봐야합니다.

1. 브라우저에 도메인 이름 `www.qq.com`을 입력하면 운영체제는 이 도메인 이름에 대한 호스트의 파일에 맵핑 관계가 있는지 확인합니다. 만약 그렇다면 도메인 이름 확인이 완료됩니다.
2. 만약 호스트의 파일에 맵핑 관계가 없으면 운영 체제는 DNS에 캐시가 있는지 확인하고 있다면 도메인 이름 확인이 완료됩니다.
3. 호스트와 DNS 캐시 모두에 맵핑 관계가 없는 경우 운영 체제는 로컬 DNS 서버인 TCP/IP 설정에서 첫 번째 DNS 확인 서버를 찾습니다. 로컬 DNS 서버가 쿼리를 받으면 쿼리 할 도메인 이름이 해당 지역 리소스의 로컬 구성에 포함되어 있는지 확인하고 결과를 클라이언트에 반환합니다. 이 DNS 확인은 신뢰할 수 있습니다.
4. 로컬 DNS 서버에 도메인 이름이 없지만 캐시에 맵핑 관계가 있는 경우 로컬 DNS 서버는 이 결과를 클라이언트에 반환하며, 이 DNS 확인은 신뢰할 수 없습니다.
5. 로컬 DNS 서버가 지역 리소스 또는 캐시의 구성으로 도메인 이름을 확인할 수 없는 경우 로컬 DNS 서버의 설정에 따라 다음 단계로 진행됩니다.
   - 로컬 DNS 서버가 전송을 활성화하지 않은 경우 요청을 루트 DNS 서버로 라우팅 한 다음 도메인 이름인 `.com`을 알 수 있는 최상위 수준 DNS의 IP 주소를 반환합니다. 첫 번째 최상위 수준 DNS 서버가 도메인 이름을 인식하지 못하면 도메인 이름을 인식 할 때까지 요청을 다음 최상위 수준 DNS 서버로 다시 라우팅합니다. 그런 다음 최상위 수준의 DNS 서버는 이 수준의 DNS 서버에 `www.qq.com`에 해당하는 IP 주소를 묻습니다.
   - 로컬 DNS 서버가 전송을 사용할 수 있는 경우 상위 DNS 서버에 요청을 전송합니다. 상위 수준 DNS 서버가 도메인 이름을 인식하지 못하면 요청은 도메인 이름을 인식하는 DNS 서버에 최종적으로 도달 할 때까지 상위 수준으로 다시 라우팅됩니다.

로컬 DNS 서버가 전송을 지원하는지 여부에 관계없이 도메인 이름의 IP 주소는 항상 로컬 DNS 서버로 돌아가고 로컬 DNS 서버는 다시 클라이언트로 보냅니다.

![](images/3.1.dns_inquery.png?raw=true)

Figure 3.3 DNS 확인 절차

`재귀 쿼리 프로세스`는 단순히 말해 프로세스에서 검색자를 바꾸는 것을 의미합니다. 검색자는 `반복 쿼리 프로세스`에선 변하지 않습니다.

이제 우리는 클라이언트가 결국 IP 주소를 얻음으로써 브라우저가 IP 주소를 통해 서버와 통신하고있음을 알게되었습니다.

## HTTP 프로토콜

HTTP 프로토콜은 웹 서비스의 핵심 부분입니다. 웹의 작동 방식을 이해하기 전에 HTTP 프로토콜이 무엇인지 파악하는 것이 중요합니다.

HTTP는 브라우저와 웹 서버 간의 통신을 쉽게하는 데 사용되는 프로토콜입니다. TCP 프로토콜을 기반으로하며 일반적으로 웹 서버 측에서 포트 80을 사용합니다. 이것은 요청 및 응답 프로토콜입니다 - 클라이언트가 요청을 보내고 서버가 이 요청에 응답합니다. HTTP 프로토콜에 따르면 클라이언트는 항상 새 연결을 설정하고 서버에 HTTP 요청을 보냅니다. 서버는 미리 클라이언트에 연결하거나 콜백 연결을 설정할 수 없습니다.  클라이언트와 서버 간의 연결은 양쪽에서 끊을 수 있습니다. 예를 들어 여러분이 다운로드 요청 및 HTTP 연결을 취소 할 수 있으며, 브라우저가 다운로드를 완료하기 전에 서버와 연결을 끊을 수도 있습니다.

HTTP 프로토콜은 상태를 가지고있지 않습니다. 무슨 의미냐면 서버는 동일한 클라이언트에서 두 번의 서버 요청이 와도 그 관계에 대해 알지 못합니다. 이 문제를 해결하기 위해 웹 어플리케이션은 쿠키를 사용하여 연결 상태를 유지합니다.

Because the HTTP protocol is based on the TCP protocol, all TCP attacks will affect HTTP communications in your server. Examples of such attacks are SYN flooding, DoS and DDoS attacks.

HTTP 프로토콜은 TCP 프로토콜을 기반으로하기 때문에 모든 TCP 공격은 서버의 HTTP 통신에 영향을 미칩니다. 이러한 공격의 예는 SYN 플러딩, DoS, DDoS가 있습니다.

### HTTP 요청 패키지 (브라우저 정보)

Request packages all have three parts: request line, request header, and body. There is one blank line between header and body. 

요청 패키지는 request line, request header 및 body 이렇게 3가지를 가지고있고, header와 body 사이에 빈 줄이 하나 있습니다. 

	GET /domains/example/ HTTP/1.1      // request line: 요청 방법, URL, protocol 및 버전
	Host：www.iana.org             // 도메인 이름
	User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4            // 브라우저 정보
	Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8    // 클라이언트가 받아 들일 수 있는 mime
	Accept-Encoding：gzip,deflate,sdch     // 스트림 컴프레션
	Accept-Charset：UTF-8,*;q=0.5      // 클라이언트에서의 문자열 세트
	// 빈 줄
	// body, 요청 자원 요소 (예를들면, POST 요소)

다음 요청을 정보를 얻기 위해 fiddler를 사용합니다. (***구글 크롬 개발자 도구에서도 확인할 수 있습니다.***)

![](images/3.1.http.png?raw=true)

Figure 3.4 fiddler가 얻은 GET 요청에 대한 정보

![](images/3.1.httpPOST.png?raw=true)

Figure 3.5 fiddler가 얻은 POST 요청에 대한 정보

**POST와 달리 GET에는 요청 body가 없다는 것을 알 수 있습니다.**

HTTP로 서버와 통신하는 데 사용할 수 있는 여러가지 방법이 있습니다. GET, POST, PUT, DELETE는 우리가 일반적으로 사용하는 4가지 기본 방법입니다. URL은 네트워크의 자원을 나타내므로 네 가지 메소드는 이러한 자원에 대해 작동 할 수 있는 쿼리, 변경, 추가 및 삭제 작업을 정의합니다. GET, POST는 HTTP에서 매우 일반적으로 사용합니다. GET은 `?`를 사용하여 URL과 매개 변수를 분리하고 `EditPosts.aspx?name=test1&id=123456`처럼 인수 사이에 `&`를 사용하여 URL에 쿼리 매개 변수를 추가 할 수 있습니다. POST에선 URL이 브라우저에 의해 길이 제한을 가지고 있기 때문에 요청 body에 데이터를 저장합니다. 따라서 POST는 GET보다 훨씬 많은 데이터를 보낼 수 있습니다. 또한 사용자 이름과 비밀번호를 보낼 때 이러한 종류의 정보가 URL에 나타나기를 원하지 않으므로 POST를 사용하여 보이지 않게합니다.

### HTTP 응답 패키지 (서버 정보)

응답 패키지엔 어떤 정보가 들어 있는지 살펴 보겠습니다.

	HTTP/1.1 200 OK                     // 상태 줄
	Server: nginx/1.0.8                 // 웹 서버 소프트웨어 및 서버 시스템의 해당 버전
	Date:Date: Tue, 30 Oct 2012 04:14:25 GMT        // 응답 시간
	Content-Type: text/html             // 응답 데이터 타입
	Transfer-Encoding: chunked          // 데이터가 쪼개져 전송되었음을 의미합니다.
	Connection: keep-alive              // 연결 유지
	Content-Length: 90                  // body의 길이
	// 빈 줄
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"... // 메시지 body

첫 번째 줄을 상태 줄이라고합니다. HTTP 버전, 상태 코드 및 상태 메시지를 제공합니다.

상태 코드는 클라이언트에게 HTTP 서버의 응답 상태를 알려줍니다. HTTP / 1.1에서는 5 가지 종류의 상태 코드가 정의되었습니다.

	- 1xx 정보제공
	- 2xx 성공
	- 3xx 리다이렉트
	- 4xx 클라이언트 에러
	- 5xx 서버 에러

응답 패키지에 대해 더 많은 예제를 살펴 보겠습니다. 200은 서버가 올바르게 응답했음을 의미하고 302는 리다이렉션을 의미합니다.

![](images/3.1.response.png?raw=true)

Figure 3.6 웹사이트를 방문하기위한 모든 정보

### HTTP가 상태 저장 능력이 없는 것과 Connection: keep-alive와의 관계

상태 비 저장이라는 말은 서버가 연결을 유지할 능력이 없음을 의미하지 않습니다. 이는 서버가 두 요청 사이의 관계를 인식하지 못한다는 것을 의미합니다.

HTTP / 1.1에서는 Keep-alive가 기본적으로 사용됩니다. 클라이언트에 추가 요청이있는 경우에는 동일한 연결을 사용합니다.

Keep-alive는 하나의 연결을 영원히 유지할 수 없습니다. 서버에서 실행중인 응용 프로그램은 연결을 유지할 한계를 결정하며, 대부분의 경우 이 한계를 설정 할 수 있습니다.

## 인스턴스 요청

![](images/3.1.web.png?raw=true)

Figure 3.7 하나의 웹 페이지를 열기 위한 모든 패키지

위의 그림에서 클라이언트와 서버 간의 전체 통신 프로세스를 볼 수 있습니다. 목록에 많은 리소스 파일이 있음을 알 수 있습니다. 이를 정적 파일이라고하며 Go에는 이러한 파일에 대한 특수 처리 방법이 있습니다.

이것은 브라우저의 가장 중요한 기능입니다. URL을 요청하고 웹 서버에서 데이터를 검색 한 다음 HTML을 렌더링합니다. CSS 또는 JS 파일과 같은 DOM에서 일부 파일을 찾으면 브라우저는 모든 리소스가 화면에서 렌더링을 완료 할 때까지 서버에서 이러한 리소스를 다시 요청합니다.

HTTP 요청 시간을 줄이는 것은 웹 페이지의 로드 속도를 향상시키는 한 가지 방법입니다. 로드해야하는 CSS 및 JS 파일의 수를 줄임으로써 동시에 웹 서버의 대기 시간과 압력을 줄일 수 있습니다.

## 링크

- [목차](preface.md)
- Previous section: [Web 기초](03.0.md)
- Next section: [간단한 웹 서버 만들기](03.2.md)
