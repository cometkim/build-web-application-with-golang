# 2.3 제어문과 함수

이 장에서는, Go의 제어문과 함수에 대해서 살펴보겠습니다.

## 제어문

프로그래밍에서의 가장 훌륭한 발명품은 바로 흐름 제어입니다. 이것 덕분에, 여러분은 복잡한 로직을 간단한 제어문으로 표현할 수 있습니다. 흐름 제어에는 세가지 종류가 있습니다: 조건부, 순환 제어 및 무조건부 점프.

### if

`if`는 프로그램에서의 가장 일반적인 키워드입니다. 조건을 충족하면, 특정 작업을 수행하며 그 외의 경우 다른 작업을 수행합니다.

Go의 `if`에는 괄호가 필요하지 않습니다.

```go
if x > 10 {
	fmt.Println("x is greater than 10")
} else {
	fmt.Println("x is less than or equal to 10")
} 
```

Go의 `if`에서 가장 유용한건 조건문 앞에 초기화문을 가질 수 있다는 것입니다. 초기화문에서 정의된 변수의 스코프는 `if`로 정의된 블록에서만 유효합니다.

```go
// x를 초기화하고, x가 10보다 큰지 확인합니다
if x := computedValue(); x > 10 {
	fmt.Println("x is greater than 10")
} else {
	fmt.Println("x is less than 10")
}

// 다음 코드는 컴파일되지 않습니다
fmt.Println(x)
```

다중 조건은 if-else를 사용합니다.

```go
if integer == 3 {
	fmt.Println("The integer is equal to 3")
} else if integer < 3 {
	fmt.Println("The integer is less than 3")
} else {
	fmt.Println("The integer is greater than 3")
}
```

### goto

Go에는 `goto` 키워드가 있습니다만, 주의해서 사용해야합니다. `goto`는 동일한 코드 블록의 바디 내에서 이전에 정의된 `label`로 흐름 제어의 경로를 바꿉니다.

```go
func myFunc() {
	i := 0
Here:   // 라벨은 ":"로 끝납니다
	fmt.Println(i)
	i++
	goto Here   // "Here" 라벨로 이동
}
```

라벨명은 대소문자를 구분합니다.

### for

`for`는 Go에서 가장 강력한 제어 로직입니다. 이는 `while`과 같이 루프에서 데이터를 읽고 반복적으로 연산을 수행할 수 있습니다.

```go
for expression1; expression2; expression3 {
	//...
}
```

`expression1`, `expression2` 및 `expression3`은 모두 표현식이며, `expression1`과 `expression3`은 변수 정의 또는 함수에서의 반환값이고, `expression2`는 조건문입니다. `expression1`은 루프를 순회하기 전에 한 번 실행되며, `expression3`는 각 루프가 끝날때마다 실행됩니다.

말로하는 것보다 예제를 한 번 살펴보겠습니다.

```go
package main
import "fmt"

func main(){
	sum := 0;
	for index:=0; index < 10 ; index++ {
    	sum += index
	}
	fmt.Println("sum is equal to ", sum)
}
// sum is equal to 45가 출력됩니다
```

종종 다중 할당이 필요한 경우가 있는데, Go는 `,` 연산자가 없기 때문에, `i, j = i + 1, j - 1`와 같이 병렬 할당을 할 수 있습니다.

필요 없는 경우 `expression1`과 `expression3`는 생략할 수 있습니다.

```go
sum := 1
for ; sum < 1000;  {
	sum += sum
}
```

`;` 또한 생략 가능합니다. 익숙하지 않나요? 맞습니다. `while`과 똑같습니다.

```go
sum := 1
for sum < 1000 {
	sum += sum
}
```

루프에는 두 가지 중요한 연산이 있는데 `break`와 `continue`입니다. `break`는 루프를 빠져나오며, `continue`는 현재 루프를 빠져나가 다음 루프를 시작합니다. 중첩 루프를 사용한다면, `break`을 라벨과 함께 사용하세요.

```go
for index := 10; index>0; index-- {
	if index == 5{
    	break // 또는 continue
	}
	fmt.Println(index)
}
// break를 사용하면 10, 9, 8, 7, 6이 출력됩니다
// continue를 사용하면 10、9、8、7、6、4、3、2、1이 출력됩니다
```

`for`를`range`와 함께 사용하면 `slice`와 `map`의 데이터를 읽을 수 있습니다.

```go
for k,v:=range map {
	fmt.Println("map's key:",k)
	fmt.Println("map's val:",v)
}
```

Go는 다중값 반환을 지원하고 정의된 값을 사용하지 않으면 컴파일 에러를 발생시키기 때문에, `_`를 사용해 특정값을 무시합니다.

```go
for _, v := range map{
	fmt.Println("map's val:", v)
}
```

### switch

어떤 로직을 구현하기 위해 너무 많은 `if-else`문을 사용하는 경우가 있는데, 이는 코드를 읽기 어렵게하며 추후에 유지보수 하기를 어렵게 만듭니다. 이 문제를 해결하기 위해 `switch`를 사용할 수 있습니다.

```go
switch sExpr {
case expr1:
	some instructions
case expr2:
	some other instructions
case expr3:
	some other instructions
default:
	other code
}
```

`sExpr`, `expr1`, `expr2`와 `expr3`는 반드시 같은 타입이어야 합니다. `switch`는 매우 유연합니다. 조건은 반드시 상수일 필요는 없으며 스위치문은 조건이 맞을때까지 위에서부터 아래로 실행됩니다. `switch` 키워드 다음에 아무 명령문도 없을 경우엔 `true`로 매칭됩니다.

```go
i := 10
switch i {
case 1:
	fmt.Println("i is equal to 1")
case 2, 3, 4:
	fmt.Println("i is equal to 2, 3 or 4")
case 10:
	fmt.Println("i is equal to 10")
default:
	fmt.Println("All I know is that i is an integer")
}
```

5번째 라인에서, 하나의 `case`에 여러개의 값을 넣었으며, `case` 바디 끝에는 `break` 키워드를 추가할 필요가 없습니다. 케이스중 하나만 매칭되면 스위치문을 빠져나갑니다. 하나 이상의 케이스를 매칭시켜 진행하려면, `fallthrough`문을 사용해야합니다.

```go
integer := 6
switch integer {
case 4:
	fmt.Println("integer <= 4")
	fallthrough
case 5:
	fmt.Println("integer <= 5")
	fallthrough
case 6:
	fmt.Println("integer <= 6")
	fallthrough
case 7:
	fmt.Println("integer <= 7")
	fallthrough
case 8:
	fmt.Println("integer <= 8")
	fallthrough
default:
	fmt.Println("default case")
}
```

이 프로그램은 다음을 출력합니다.

```
integer <= 6
integer <= 7
integer <= 8
default case
```

## 함수

함수를 정의하기 위해선 `func` 키워드를 사용합니다.

```go
func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {
    // 함수 바디
    // 다중값 반환
	return value1, value2
}
```

우리는 위의 예제로부터 다음의 정보들을 추론할 수 있습니다.

- `funcName` 함수를 정의하기 위해 `func` 키워드를 사용합니다.
- 함수는 0개, 1개 또는 그 이상의 인자를 가집니다. 인자 타입은 인자명 뒤에 오며 인자들은 `,`로 구분됩니다.
- 함수는 다중값을 반환할 수 있습니다.
- 위에서는 `output1`과 `output2`로 명명된 두 개의 반환값이 있는데, 이름을 생략하고 타입만 사용할 수도 있습니다.
- 만약 반환값이 하나밖에 없고 반환값명을 생략한다면, 반환값에 괄호가 필요 없습니다.
- 함수에 반환값이 없으면, 반환 파라미터를 모두 생략할 수 있습니다.
- 함수가 반환값을 가지면, 함수 바디의 어딘가에는 `return`문이 있어야 합니다.

실용적인 예제 하나를 살펴봅시다. (최대값 계산하기)

```go
package main
import "fmt"

// a와 b중 큰 수를 반환
func max(a, b int) int {
	if a > b {
    	return a
	}
	return b
}

func main() {
	x := 3
	y := 4
	z := 5

	max_xy := max(x, y) // max(x, y) 함수 호출
	max_xz := max(x, z) // max(x, z) 함수 호출

	fmt.Printf("max(%d, %d) = %d\n", x, y, max_xy)
	fmt.Printf("max(%d, %d) = %d\n", x, z, max_xz)
	fmt.Printf("max(%d, %d) = %d\n", y, z, max(y,z)) // Printf에서 함수 호출
}
```

위의 예제를 보면, `max` 함수에 두 개의 인자가 있고, 두 인자 모두 `int`타입이기 때문에 첫 번째 인자의 타입은 생략이 가능합니다. 예를 들어, `a int, b int` 대신 `a, b int`을 사용합니다. 추가적인 인자에 대해서도 같은 규칙이 적용됩니다. `max`가 단 하나의 반환값만 가지므로, 반환값의 타입만 적어도 된다는것에 주목하세요.

### 다중값 반환

Go가 C보다 좋은점은 다중값 반환을 지원한다는 것입니다.

다음의 예제를 살펴봅시다.

```go
package main
import "fmt"

// A + B와 A * B의 결괏값을 반환
func SumAndProduct(A, B int) (int, int) {
return A+B, A*B
}

func main() {
	x := 3
	y := 4

	xPLUSy, xTIMESy := SumAndProduct(x, y)

	fmt.Printf("%d + %d = %d\n", x, y, xPLUSy)
	fmt.Printf("%d * %d = %d\n", x, y, xTIMESy)
}
```

위 예제는 이름 없이 두 개의 값을 반환합니다 - 여기에 이름을 붙일 수도 있습니다. 반환값에 이름을 부여하면, 함수 내에서 자동으로 초기화되기 때문에 값을 반환하기 위해선 그냥 `return`만 사용하면 됩니다. 참고로 만약 여러분의 함수가 패키지 밖에서 사용될 경우, 즉 함수명이 대문자로 시작하는 경우, 완전한 `return`문을 사용하는게 더 좋을 것입니다; 이는 코드의 가독성을 높입니다.

```go
func SumAndProduct(A, B int) (add int, multiplied int) {
	add = A+B
	multiplied = A*B
	return
}
```

### 가변 인자 함수

Go는 가변 개수의 인자를 갖는 함수를 지원합니다. 이 함수들을 "가변적이다"라고 부르며, 함수가 확정되지 않은 갯수의 인자를 허용함을 의미합니다.

```go
func myfunc(arg ...int) {}
```
`arg …int`는 Go에게 함수가 가변 인자를 가짐을 알려줍니다. 위에서 인자들의 타입은 `int`입니다. 함수의 바디에서, `arg`는 `int`의 `slice`가 됩니다.

```go
for _, n := range arg {
	fmt.Printf("And the number is: %d\n", n)
}
```

### 값과 포인터에 의한 전달

함수를 호출할 때 인자를 넘기면, 그 함수는 실제로 변수의 값을 복사해 사용하기 때문에 이 인자값에 변화를 줘도 원래값에는 영향을 미치지 않습니다.

제가 하는 말을 증명하기 위해 하나의 예를 들어보겠습니다.

```go
package main
import "fmt"

// a에 1을 더하는 간단한 함수
func add1(a int) int {
	a = a+1 // a의 값을 변경합니다
	return a // a의 새로운 값을 반환합니다
}

func main() {
	x := 3

	fmt.Println("x = ", x)  // "x = 3"를 출력합니다

	x1 := add1(x)  // add1(x) 호출

	fmt.Println("x+1 = ", x1) // "x+1 = 4"를 출력합니다
	fmt.Println("x = ", x)    // "x = 3"을 출력합니다
}
```

보셨나요? `x`를 사용하는 `add1`을 호출했지만, `x`의 원래값은 변하지 않습니다.

이유는 매우 단순합니다: `add1`을 호출할 때, `x`의 복사본을 받을뿐 `x` 자체를 사용하진 않습니다.

이제 여러분은 실제 `x`를 함수에 전달하는 방법에 대해 질문을 할 것 입니다.

여기서 우리는 포인터를 사용해야합니다. 우리는 변수가 메모리에 저장되어 있고 그들은 메모리 주소를 가지고 있음을 알고 있습니다. 따라서, 변수의 값을 변경하고 싶으면, 이 변수의 메모리 주소를 변경해야합니다. 따라서, `add1` 함수가 `x`의 값을 변경하기 위해서는 `x`의 메모리 주소를 알아야합니다. 다음은 함수에 `&x`를 전달하며, 인자 타입을 포인터 타입인 `*int`로 변경합니다. 값의 복사본이 아닌 포인터의 복사본을 전달하고 있음을 숙지하세요.

```go
package main
import "fmt"

// a에 1을 더하는 간단한 함수
func add1(a *int) int {
	*a = *a+1 // a의 값을 변경합니다
	return *a // a의 새로운 값을 반환합니다
}

func main() {
	x := 3

	fmt.Println("x = ", x)  // "x = 3"을 출력합니다

	x1 := add1(&x)  // add(&x)를 호출해 x의 메모리 주소를 전달합니다

	fmt.Println("x+1 = ", x1) // "x+1 = 4"를 출력합니다
	fmt.Println("x = ", x)    // "x = 4"를 출력합니다
}
```

이제 우리는 함수 내에서 `x`의 값을 변경할 수 있습니다. 왜 포인터를 사용할까요? 장점이 무엇일까요?

- 하나의 변수에서 여러 함수를 사용할 수 있도록 해줍니다.
- 메모리 주소 (8 바이트)를 전달하면 값을 전달하는 비효율적인 복사보다 시간과 공간 모든 측면에서 비용이 낮습니다. 
- `channel`, `slice` 및 `map`은 레퍼런스 타입이기 때문에 기본적으로 포인터로 함수에 전달됩니다. (주의: `slice`의 길이를 바꾸기 위해서는, 명시적으로 포인터를 전달해야합니다)

### defer

Go는 `defer`라는 잘 만들어진 키워드가 있습니다. 하나의 함수에 여러개의 `defer`문을 가질 수 있습니다; 이들은 프로그램이 함수의 마지막 부분을 실행할 때 역순으로 실행됩니다. 프로그램이 어떤 리소스 파일을 여는 경우, 이 파일들은 함수가 에러와 함께 반환되기 전에 닫아야 합니다. 몇 가지 예제를 봅시다.

```go
func ReadWrite() bool {
	file.Open("file")
// 작업 수행
	if failureX {
    	file.Close()
    	return false
	}

	if failureY {
    	file.Close()
    	return false
    }

	file.Close()
	return true
}
```

일부 코드가 반복되고 있음을 볼 수 있습니다.`defer`는 이 문제를 훌륭하게 해결합니다. 이는 코드를 깔끔하게 할 뿐만 아니라 가독성 또한 높여줍니다.

```go
func ReadWrite() bool {
	file.Open("file")
	defer file.Close()
	if failureX {
    	return false
	}
	if failureY {
    	return false
	}
	return true
}
```

하나 이상의 `defer`가 있으면, 이들은 역순으로 실행됩니다. 다음 예시는 `4 3 2 1 0`을 출력합니다.

```go
for i := 0; i < 5; i++ {
	defer fmt.Printf("%d ", i)
}
```

### 값과 타입으로써의 함수

Go에서는 함수 또한 변수이며, 함수를 정의할 때 `type`을 사용할 수 있습니다. 다음과 동일한 시그니쳐를 갖는 함수들은 같은 타입입니다.

```go
type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...])
```
이 특징의 이점은 무엇일까요? 답은 바로 함수를 값으로써 전달할 수 있다는 것입니다.

```go
package main
import "fmt"

type testInt func(int) bool // 변수의 함수 타입을 정의합니다

func isOdd(integer int) bool {
	if integer%2 == 0 {
    	return false
	}
	return true
}

func isEven(integer int) bool {
	if integer%2 == 0 {
    	return true
	}
	return false
}

// 다른 함수의 인자로써 함수 `f`를 전달합니다
func filter(slice []int, f testInt) []int {
	var result []int
	for _, value := range slice {
    	if f(value) {
        	result = append(result, value)
    	}
	}
	return result
}

func main(){
	slice := []int {1, 2, 3, 4, 5, 7}
	fmt.Println("slice = ", slice)
	odd := filter(slice, isOdd)    // 함수를 값으로써 사용합니다
	fmt.Println("Odd elements of slice are: ", odd)
	even := filter(slice, isEven) 
	fmt.Println("Even elements of slice are: ", even)
}
```

이는 인터페이스를 사용할 때 매우 유용합니다. `testInt`가 함수를 타입으로 갖는 변수임을 볼 수 있으며 `filter`의 반환값과 인자가 `testInt`의 그것들과 동일합니다. 따라서, 우리는 코드의 유연성을 유지하면서 복잡한 로직을 가질 수 있습니다.

### Panic과 Recover

Go는 Java가 가진 `try-catch` 구조를 가지지 않습니다. 예외를 발생시키는 대신, Go는 에러를 처리하기 위해 `panic`과 `recover`를 사용합니다. 그러나, `panic`은 강력함에도 불구하고 매우 자주 사용해서는 안됩니다.

`Panic`은 프로그램의 정상적인 흐름을 깨뜨리고 패닉 상태로 들어가는 내장 함수입니다. 함수 `F`가 `panic`을 호출하면, `F`는 실행을 멈추지만 `defer` 함수는 계속 실행을 진행합니다. 그 다음 `F`는 패닉 상태를 발생시킨 중단점으로 돌아갑니다. 이 모든 함수가 패닉 상태에서 그 `goroutine`의 첫번째 레벨로 돌아올 때까지 프로그램은 종료되지 않습니다. `panic`은 프로그램에서 `panic`을 호출함으로써 발생될 수 있으며, 범위 밖의 배열 접근과 같은 몇몇 에러 또한 `panic`을 발생시킵니다.

`Recover`는 패닉 상태로부터 `goroutine`을 복구하는 내장 함수입니다. `defer` 함수에서 `recover`를 호출하는건 유용한데 일반 함수는 프로그램이 패닉 상태에 빠졌을때 실행되지 않기 때문입니다. 이는 프로그램이 패닉 상태에 빠졌을 경우 `panic`을 잡아내며, 프로그램이 패닉 상태가 아닌 경우엔 `nil`을 받습니다.

다음 예제는 `panic`의 사용법을 보여줍니다.

```go
var user = os.Getenv("USER")
```

```go
func init() {
	if user == "" {
    	panic("no value for $USER")
	}
}
```

다음 예제는 `panic`을 확인하는 방법을 보여줍니다.

```go
func throwsPanic(f func()) (b bool) {
	defer func() {
    	if x := recover(); x != nil {
        	b = true
    	}
	}()
	f() // f가 패닉을 발생시키면, 이를 복구합니다
	return
}
```

### `main` 함수와 `init` 함수

Go에는 `main`과 `init`이라는 두 개의 리텐션이 있으며, `init`은 모든 패키지에서 사용 가능하고 `main`은 `main` 패키지에서만 사용이 가능합니다. 이 두 함수는 인자나 반환값을 가질 수 없습니다. 한 패키지에 여러개의 `init` 함수를 정의할 수는 있지만, 각 패키지마다 단 하나의 `init` 함수만 정의하는걸 강력히 추천합니다.

Go 프로그램은 `init()`과 `main()`을 자동으로 호출하므로, 스스로 이 함수들을 호출할 필요는 없습니다. 모든 패키지에 대해 `init` 함수는 선택사항이지만, `package main`는 단 하나의 `main` 함수를 필수적으로 가져야합니다.

프로그램은 초기화 후 `main` 패키지로부터 실행을 시작합니다. `main` 패키지가 다른 패키지를 임포트하고 있으면, 그것들은 컴파일시에 임포트됩니다. 패키지를 임포트 한 후에, 프로그램은 임포트된 패키지의 상수와 변수들을 초기화하고, 존재할 경우 `init`을 실행합니다. 모든 패키지가 초기화되면, 프로그램은 `main` 패키지의 상수와 변수들을 초기화하고. 존재할 경우 `init` 함수를 실행합니다. 다음 그림은 위 과정을 보여줍니다.

![](images/2.3.init.png?raw=true)

Figure 2.6 Go의 프로그램 초기화 흐름

### import

우리는 Go 프로그램에서 `import`를 다음과 같이 자주 사용합니다.

```go
import(
	"fmt"
)
```

그리고 패키지의 함수를 다음과 같이 사용합니다.

```go
fmt.Println("hello world")
```
 `fmt`는 Go 표준 라이브러리에서 가져온 것으로 $GOROOT/pkg 내에 존재합니다. Go는 두 가지 방법으로 서드 파티 패키지를 지원합니다.

1. 상대경로
   `import "./model"` 는 같은 디렉토리의 패키지를 로드합니다. 이 방법은 추천하지 않습니다.  
2. 절대경로
   `import "shorturl/model"`은 "$GOPATH/pkg/shorturl/model" 경로에 있는 패키지를 로드합니다.

다음은 패키지를 임포트 할 때 사용할 수 있는 몇 가지 특별한 연산자들이며, 초보자는 다음 연산자들을 항상 헷갈려합니다.

1. 닷 (Dot) 연산자.
   어떤 사람들은 종종 다음과 같이 패키지를 임포트 하는걸 볼 수 있습니다.

   ```go
   import(
   	. "fmt"
   )
   ```
   닷 연산자는 패키지의 함수를 사용할 때 패키지명을 생략할 수 있음을 의미합니다. 이제 `fmt.Printf("Hello world")`는 `Printf("Hello world")`로 바뀝니다.

2. 별칭 연산.
   이는 임포트한 패키지에 속한 함수를 사용할 때 패키지명을 바꿉니다.

   ```go
   import(
   	f "fmt"
   )
   ```
   이제 `fmt.Printf("Hello world")`는 `f.Printf("Hello world")`로 바뀝니다.

3. `_` 연산자.
   이는 누군가가 여러분에게 설명해주지 않으면 이해하기 어려운 연산자입니다.

   ```go
   import (
   	"database/sql"
   	_ "github.com/ziutek/mymysql/godrv"

   )
   ```
   `_` 연산자는 패키지를 임포트하고 그저 패키지의 `init` 함수만 실행시키고, 패키지 내의 함수들은 사용하지 않을 것임을 의미합니다.

## 링크

- [목차](preface.md)
- 이전 장: [Go 기초](02.2.md)
- 다음 장: [구조체](02.4.md)
